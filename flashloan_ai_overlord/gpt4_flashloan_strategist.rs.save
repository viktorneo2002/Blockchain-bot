use anchor_client::{Client, Cluster, Program};
use anchor_lang::prelude::*;
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    compute_budget::ComputeBudgetInstruction,
    instruction::Instruction,
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use std::{
    collections::HashMap,
    str::FromStr,
    sync::{Arc, Mutex},
    time::{Duration, Instant},
};
use tokio::time::interval;

const JUPITER_V6_PROGRAM: &str = "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4";
const RAYDIUM_V4_PROGRAM: &str = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8";
const ORCA_WHIRLPOOL_PROGRAM: &str = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
const SOLEND_PROGRAM: &str = "So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo";
const PRIORITY_FEE_PERCENTILE: u64 = 95;
const MIN_PROFIT_THRESHOLD_LAMPORTS: u64 = 1_000_000;
const MAX_COMPUTE_UNITS: u32 = 1_400_000;
const FLASHLOAN_FEE_BPS: u64 = 9;

#[derive(Debug, Clone)]
pub struct ArbitragePath {
    pub dex_a: DexType,
    pub dex_b: DexType,
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub pool_a: Pubkey,
    pub pool_b: Pubkey,
    pub expected_profit: u64,
    pub amount_in: u64,
    pub priority_fee: u64,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DexType {
    Jupiter,
    Raydium,
    Orca,
}

pub struct FlashloanStrategist {
    client: Arc<RpcClient>,
    wallet: Arc<Keypair>,
    jupiter_client: Arc<JupiterClient>,
    raydium_client: Arc<RaydiumClient>,
    orca_client: Arc<OrcaClient>,
    solend_client: Arc<SolendClient>,
    price_cache: Arc<Mutex<HashMap<String, PriceData>>>,
    recent_txs: Arc<Mutex<Vec<RecentTransaction>>>,
}

#[derive(Clone)]
struct PriceData {
    price: f64,
    liquidity: u64,
    timestamp: Instant,
}

#[derive(Clone)]
struct RecentTransaction {
    signature: String,
    profit: i64,
    timestamp: Instant,
}

struct JupiterClient {
    program_id: Pubkey,
}

impl JupiterClient {
    fn new() -> Self {
        Self {
            program_id: Pubkey::from_str(JUPITER_V6_PROGRAM).unwrap(),
        }
    }

    async fn get_quote(&self, input_mint: &Pubkey, output_mint: &Pubkey, amount: u64) -> Result<Quote, Box<dyn std::error::Error>> {
        let url = format!(
            "https://quote-api.jup.ag/v6/quote?inputMint={}&outputMint={}&amount={}&slippageBps=10&onlyDirectRoutes=true",
            input_mint, output_mint, amount
        );
        let response: serde_json::Value = reqwest::get(&url).await?.json().await?;
        Ok(Quote {
            in_amount: amount,
            out_amount: response["outAmount"].as_str().unwrap_or("0").parse()?,
            price_impact: response["priceImpactPct"].as_str().unwrap_or("0").parse()?,
        })
    }

    fn build_swap_ix(&self, wallet: &Pubkey, quote: &Quote, route: Vec<Pubkey>) -> Instruction {
        let accounts = vec![
            AccountMeta::new(*wallet, true),
            AccountMeta::new_readonly(self.program_id, false),
        ];
        for pubkey in route {
            accounts.push(AccountMeta::new(pubkey, false));
        }
        Instruction {
            program_id: self.program_id,
            accounts,
            data: self.encode_swap_data(quote),
        }
    }

    fn encode_swap_data(&self, quote: &Quote) -> Vec<u8> {
        let mut data = vec![0x69, 0x4b, 0x5e, 0xaf];
        data.extend_from_slice(&quote.in_amount.to_le_bytes());
        data.extend_from_slice(&quote.out_amount.to_le_bytes());
        data
    }
}

struct RaydiumClient {
    program_id: Pubkey,
}

impl RaydiumClient {
    fn new() -> Self {
        Self {
            program_id: Pubkey::from_str(RAYDIUM_V4_PROGRAM).unwrap(),
        }
    }

    async fn get_pool_info(&self, pool: &Pubkey, client: &RpcClient) -> Result<PoolInfo, Box<dyn std::error::Error>> {
        let account = client.get_account(pool)?;
        let data = &account.data;
        Ok(PoolInfo {
            token_a_reserve: u64::from_le_bytes(data[85..93].try_into()?),
            token_b_reserve: u64::from_le_bytes(data[93..101].try_into()?),
            fee_numerator: u64::from_le_bytes(data[277..285].try_into()?),
            fee_denominator: u64::from_le_bytes(data[285..293].try_into()?),
        })
    }

    fn calculate_output(&self, amount_in: u64, pool_info: &PoolInfo) -> u64 {
        let amount_in_with_fee = amount_in
            .checked_mul(pool_info.fee_denominator - pool_info.fee_numerator)
            .unwrap() / pool_info.fee_denominator;
        let numerator = amount_in_with_fee.checked_mul(pool_info.token_b_reserve).unwrap();
        let denominator = pool_info.token_a_reserve.checked_add(amount_in_with_fee).unwrap();
        numerator / denominator
    }

    fn build_swap_ix(&self, wallet: &Pubkey, pool: &Pubkey, amount_in: u64, minimum_out: u64) -> Instruction {
        let accounts = vec![
            AccountMeta::new_readonly(self.program_id, false),
            AccountMeta::new(*pool, false),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new(*wallet, true),
        ];
        let mut data = vec![0x09];
        data.extend_from_slice(&amount_in.to_le_bytes());
        data.extend_from_slice(&minimum_out.to_le_bytes());
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

struct OrcaClient {
    program_id: Pubkey,
}

impl OrcaClient {
    fn new() -> Self {
        Self {
            program_id: Pubkey::from_str(ORCA_WHIRLPOOL_PROGRAM).unwrap(),
        }
    }

    async fn get_whirlpool_data(&self, pool: &Pubkey, client: &RpcClient) -> Result<WhirlpoolData, Box<dyn std::error::Error>> {
        let account = client.get_account(pool)?;
        let data = &account.data;
        Ok(WhirlpoolData {
            sqrt_price: u128::from_le_bytes(data[65..81].try_into()?),
            liquidity: u128::from_le_bytes(data[81..97].try_into()?),
            fee_rate: u16::from_le_bytes(data[116..118].try_into()?),
        })
    }

    fn calculate_output(&self, amount_in: u64, whirlpool: &WhirlpoolData) -> u64 {
        let fee_amount = (amount_in as u128 * whirlpool.fee_rate as u128) / 1_000_000;
        let amount_after_fee = amount_in as u128 - fee_amount;
        let price = (whirlpool.sqrt_price * whirlpool.sqrt_price) >> 64;
        ((amount_after_fee * price) >> 64) as u64
    }

    fn build_swap_ix(&self, wallet: &Pubkey, whirlpool: &Pubkey, amount: u64, other_amount_threshold: u64) -> Instruction {
        let accounts = vec![
            AccountMeta::new_readonly(self.program_id, false),
            AccountMeta::new(*whirlpool, false),
            AccountMeta::new(*wallet, true),
            AccountMeta::new_readonly(spl_token::id(), false),
        ];
        let mut data = vec![0xf8, 0xc6, 0x9e, 0x91];
        data.extend_from_slice(&amount.to_le_bytes());
        data.extend_from_slice(&other_amount_threshold.to_le_bytes());
        data.push(1);
        data.extend_from_slice(&[0u8; 2]);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

struct SolendClient {
    program_id: Pubkey,
}

impl SolendClient {
    fn new() -> Self {
        Self {
            program_id: Pubkey::from_str(SOLEND_PROGRAM).unwrap(),
        }
    }

    fn build_flashloan_begin_ix(&self, wallet: &Pubkey, lending_market: &Pubkey, amount: u64) -> Instruction {
        let accounts = vec![
            AccountMeta::new(*wallet, true),
            AccountMeta::new(*lending_market, false),
            AccountMeta::new_readonly(self.program_id, false),
            AccountMeta::new_readonly(spl_token::id(), false),
        ];
        let mut data = vec![0x0e];
        data.extend_from_slice(&amount.to_le_bytes());
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }

    fn build_flashloan_end_ix(&self, wallet: &Pubkey, lending_market: &Pubkey) -> Instruction {
        let accounts = vec![
            AccountMeta::new(*wallet, true),
            AccountMeta::new(*lending_market, false),
            AccountMeta::new_readonly(self.program_id, false),
            AccountMeta::new_readonly(spl_token::id(), false),
        ];
        Instruction {
            program_id: self.program_id,
            accounts,
            data: vec![0x0f],
        }
    }
}

#[derive(Debug)]
struct Quote {
    in_amount: u64,
    out_amount: u64,
    price_impact: f64,
}

#[derive(Debug)]
struct PoolInfo {
    token_a_reserve: u64,
    token_b_reserve: u64,
    fee_numerator: u64,
    fee_denominator: u64,
}

#[derive(Debug)]
struct WhirlpoolData {
    sqrt_price: u128,
    liquidity: u128,
    fee_rate: u16,
}

impl FlashloanStrategist {
    pub fn new(rpc_url: &str, wallet: Keypair) -> Self {
        let client = Arc::new(RpcClient::new_with_commitment(
            rpc_url.to_string(),
            CommitmentConfig::confirmed(),
        ));
        Self {
            client: client.clone(),
            wallet: Arc::new(wallet),
            jupiter_client: Arc::new(JupiterClient::new()),
            raydium_client: Arc::new(RaydiumClient::new()),
            orca_client: Arc::new(OrcaClient::new()),
            solend_client: Arc::new(SolendClient::new()),
            price_cache: Arc::new(Mutex::new(HashMap::new())),
            recent_txs: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub async fn run(&self) {
        let mut interval = interval(Duration::from_millis(100));
        loop {
            interval.tick().await;
            if let Ok(opportunities) = self.scan_arbitrage_opportunities().await {
                for opp in opportunities {
                    if opp.expected_profit > MIN_PROFIT_THRESHOLD_LAMPORTS {
                        tokio::spawn(self.execute_arbitrage(opp));
                    }
                }
            }
            self.cleanup_old_data();
        }
    }

    async fn scan_arbitrage_opportunities(&self) -> Result<Vec<ArbitragePath>, Box<dyn std::error::Error>> {
        let mut opportunities = Vec::new();
        let token_pairs = self.get_active_token_pairs().await?;
        
        for (token_a, token_b) in token_pairs {
            let paths = self.find_arbitrage_paths(&token_a, &token_b).await?;
            for path in paths {
                if let Ok(profit) = self.calculate_expected_profit(&path).await {
                    if profit > MIN_PROFIT_THRESHOLD_LAMPORTS {
                        opportunities.push(ArbitragePath {
                            expected_profit: profit,
                            priority_fee: self.calculate_priority_fee(profit),
                            ..path
                        });
                    }
                }
            }
        }
        opportunities.sort_by(|a, b| b.expected_profit.cmp(&a.expecte
