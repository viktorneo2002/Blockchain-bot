"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onBundleResult = exports.sendBundles = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const searcher_1 = require("../../sdk/block-engine/searcher");
const types_1 = require("../../sdk/block-engine/types");
const utils_1 = require("../../sdk/block-engine/utils");
const MEMO_PROGRAM_ID = 'Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo';
const sendBundles = async (c, bundleTransactionLimit, keypair, conn) => {
    try {
        const tipAccountResult = await c.getTipAccounts();
        if (!tipAccountResult.ok) {
            return tipAccountResult;
        }
        const _tipAccount = tipAccountResult.value[0];
        console.log('tip account:', _tipAccount);
        const tipAccount = new web3_js_1.PublicKey(_tipAccount);
        const balance = await conn.getBalance(keypair.publicKey);
        console.log('current account has balance: ', balance);
        let isLeaderSlot = false;
        while (!isLeaderSlot) {
            const next_leader = await c.getNextScheduledLeader();
            if (!next_leader.ok) {
                return next_leader;
            }
            const num_slots = next_leader.value.nextLeaderSlot - next_leader.value.currentSlot;
            isLeaderSlot = num_slots <= 2;
            console.log(`next jito leader slot in ${num_slots} slots`);
            await new Promise(r => setTimeout(r, 500));
        }
        const blockHash = await conn.getLatestBlockhash();
        const b = new types_1.Bundle([], bundleTransactionLimit);
        console.log(blockHash.blockhash);
        const bundles = [b];
        let maybeBundle = b.addTransactions(buildMemoTransaction(keypair, 'jito test 1', blockHash.blockhash), buildMemoTransaction(keypair, 'jito test 2', blockHash.blockhash));
        if ((0, utils_1.isError)(maybeBundle)) {
            return {
                ok: false,
                error: new searcher_1.SearcherClientError(3, // INVALID_ARGUMENT
                'Failed to add transactions to bundle', maybeBundle.message)
            };
        }
        maybeBundle = maybeBundle.addTipTx(keypair, 100000, tipAccount, blockHash.blockhash);
        if ((0, utils_1.isError)(maybeBundle)) {
            return {
                ok: false,
                error: new searcher_1.SearcherClientError(3, // INVALID_ARGUMENT
                'Failed to add tip transaction to bundle', maybeBundle.message)
            };
        }
        const results = await Promise.all(bundles.map(async (b) => {
            try {
                const resp = await c.sendBundle(b);
                if (!resp.ok) {
                    return resp;
                }
                console.log('resp:', resp.value);
                return resp;
            }
            catch (e) {
                console.error('error sending bundle:', e);
                return {
                    ok: false,
                    error: e
                };
            }
        }));
        // Check if any bundle sends failed
        const error = results.find(r => !r.ok);
        if (error && !error.ok) {
            return { ok: false, error: error.error };
        }
        // At this point we know all results are successful
        const successResults = results.filter((r) => r.ok);
        return { ok: true, value: successResults.map(r => r.value) };
    }
    catch (e) {
        return {
            ok: false,
            error: e
        };
    }
};
exports.sendBundles = sendBundles;
const onBundleResult = (c) => {
    return c.onBundleResult(result => {
        console.log('received bundle result:', result);
    }, e => {
        console.error('Bundle result error:', e);
        throw e;
    });
};
exports.onBundleResult = onBundleResult;
const buildMemoTransaction = (keypair, message, recentBlockhash) => {
    const ix = new web3_js_1.TransactionInstruction({
        keys: [
            {
                pubkey: keypair.publicKey,
                isSigner: true,
                isWritable: true,
            },
        ],
        programId: new web3_js_1.PublicKey(MEMO_PROGRAM_ID),
        data: Buffer.from(message),
    });
    const instructions = [ix];
    const messageV0 = new web3_js_1.TransactionMessage({
        payerKey: keypair.publicKey,
        recentBlockhash: recentBlockhash,
        instructions,
    }).compileToV0Message();
    const tx = new web3_js_1.VersionedTransaction(messageV0);
    tx.sign([keypair]);
    console.log('txn signature is: ', bs58_1.default.encode(tx.signatures[0]));
    return tx;
};
//# sourceMappingURL=utils.js.map