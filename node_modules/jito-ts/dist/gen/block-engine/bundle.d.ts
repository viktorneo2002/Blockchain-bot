import _m0 from "protobufjs/minimal";
import { Packet } from "./packet";
import { Header } from "./shared";
export declare const protobufPackage = "bundle";
export declare enum DroppedReason {
    BlockhashExpired = 0,
    /** PartiallyProcessed - One or more transactions in the bundle landed on-chain, invalidating the bundle. */
    PartiallyProcessed = 1,
    /** NotFinalized - This indicates bundle was processed but not finalized. This could occur during forks. */
    NotFinalized = 2,
    UNRECOGNIZED = -1
}
export declare function droppedReasonFromJSON(object: any): DroppedReason;
export declare function droppedReasonToJSON(object: DroppedReason): string;
export interface Bundle {
    header: Header | undefined;
    packets: Packet[];
}
export interface BundleUuid {
    bundle: Bundle | undefined;
    uuid: string;
}
/**
 * Indicates the bundle was accepted and forwarded to a validator.
 * NOTE: A single bundle may have multiple events emitted if forwarded to many validators.
 */
export interface Accepted {
    /** Slot at which bundle was forwarded. */
    slot: number;
    /** Validator identity bundle was forwarded to. */
    validatorIdentity: string;
}
/** Indicates the bundle was dropped and therefore not forwarded to any validator. */
export interface Rejected {
    stateAuctionBidRejected?: StateAuctionBidRejected | undefined;
    winningBatchBidRejected?: WinningBatchBidRejected | undefined;
    simulationFailure?: SimulationFailure | undefined;
    internalError?: InternalError | undefined;
    droppedBundle?: DroppedBundle | undefined;
}
/**
 * Indicates the bundle's bid was high enough to win its state auction.
 * However, not high enough relative to other state auction winners and therefore excluded from being forwarded.
 */
export interface WinningBatchBidRejected {
    /** Auction's unique identifier. */
    auctionId: string;
    /** Bundle's simulated bid. */
    simulatedBidLamports: number;
    msg?: string | undefined;
}
/** Indicates the bundle's bid was __not__ high enough to be included in its state auction's set of winners. */
export interface StateAuctionBidRejected {
    /** Auction's unique identifier. */
    auctionId: string;
    /** Bundle's simulated bid. */
    simulatedBidLamports: number;
    msg?: string | undefined;
}
/** Bundle dropped due to simulation failure. */
export interface SimulationFailure {
    /** Signature of the offending transaction. */
    txSignature: string;
    msg?: string | undefined;
}
/** Bundle dropped due to an internal error. */
export interface InternalError {
    msg: string;
}
/** Bundle dropped (e.g. because no leader upcoming) */
export interface DroppedBundle {
    msg: string;
}
export interface Finalized {
}
export interface Processed {
    validatorIdentity: string;
    slot: number;
    /** / Index within the block. */
    bundleIndex: number;
}
export interface Dropped {
    reason: DroppedReason;
}
export interface BundleResult {
    /** Bundle's Uuid. */
    bundleId: string;
    /** Indicated accepted by the block-engine and forwarded to a jito-solana validator. */
    accepted?: Accepted | undefined;
    /** Rejected by the block-engine. */
    rejected?: Rejected | undefined;
    /** Reached finalized commitment level. */
    finalized?: Finalized | undefined;
    /** Reached a processed commitment level. */
    processed?: Processed | undefined;
    /** Was accepted and forwarded by the block-engine but never landed on-chain. */
    dropped?: Dropped | undefined;
}
export declare const Bundle: {
    encode(message: Bundle, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Bundle;
    fromJSON(object: any): Bundle;
    toJSON(message: Bundle): unknown;
    create<I extends Exact<DeepPartial<Bundle>, I>>(base?: I): Bundle;
    fromPartial<I extends Exact<DeepPartial<Bundle>, I>>(object: I): Bundle;
};
export declare const BundleUuid: {
    encode(message: BundleUuid, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BundleUuid;
    fromJSON(object: any): BundleUuid;
    toJSON(message: BundleUuid): unknown;
    create<I extends Exact<DeepPartial<BundleUuid>, I>>(base?: I): BundleUuid;
    fromPartial<I extends Exact<DeepPartial<BundleUuid>, I>>(object: I): BundleUuid;
};
export declare const Accepted: {
    encode(message: Accepted, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Accepted;
    fromJSON(object: any): Accepted;
    toJSON(message: Accepted): unknown;
    create<I extends Exact<DeepPartial<Accepted>, I>>(base?: I): Accepted;
    fromPartial<I extends Exact<DeepPartial<Accepted>, I>>(object: I): Accepted;
};
export declare const Rejected: {
    encode(message: Rejected, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Rejected;
    fromJSON(object: any): Rejected;
    toJSON(message: Rejected): unknown;
    create<I extends Exact<DeepPartial<Rejected>, I>>(base?: I): Rejected;
    fromPartial<I extends Exact<DeepPartial<Rejected>, I>>(object: I): Rejected;
};
export declare const WinningBatchBidRejected: {
    encode(message: WinningBatchBidRejected, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WinningBatchBidRejected;
    fromJSON(object: any): WinningBatchBidRejected;
    toJSON(message: WinningBatchBidRejected): unknown;
    create<I extends Exact<DeepPartial<WinningBatchBidRejected>, I>>(base?: I): WinningBatchBidRejected;
    fromPartial<I extends Exact<DeepPartial<WinningBatchBidRejected>, I>>(object: I): WinningBatchBidRejected;
};
export declare const StateAuctionBidRejected: {
    encode(message: StateAuctionBidRejected, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StateAuctionBidRejected;
    fromJSON(object: any): StateAuctionBidRejected;
    toJSON(message: StateAuctionBidRejected): unknown;
    create<I extends Exact<DeepPartial<StateAuctionBidRejected>, I>>(base?: I): StateAuctionBidRejected;
    fromPartial<I extends Exact<DeepPartial<StateAuctionBidRejected>, I>>(object: I): StateAuctionBidRejected;
};
export declare const SimulationFailure: {
    encode(message: SimulationFailure, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SimulationFailure;
    fromJSON(object: any): SimulationFailure;
    toJSON(message: SimulationFailure): unknown;
    create<I extends Exact<DeepPartial<SimulationFailure>, I>>(base?: I): SimulationFailure;
    fromPartial<I extends Exact<DeepPartial<SimulationFailure>, I>>(object: I): SimulationFailure;
};
export declare const InternalError: {
    encode(message: InternalError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InternalError;
    fromJSON(object: any): InternalError;
    toJSON(message: InternalError): unknown;
    create<I extends Exact<DeepPartial<InternalError>, I>>(base?: I): InternalError;
    fromPartial<I extends Exact<DeepPartial<InternalError>, I>>(object: I): InternalError;
};
export declare const DroppedBundle: {
    encode(message: DroppedBundle, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DroppedBundle;
    fromJSON(object: any): DroppedBundle;
    toJSON(message: DroppedBundle): unknown;
    create<I extends Exact<DeepPartial<DroppedBundle>, I>>(base?: I): DroppedBundle;
    fromPartial<I extends Exact<DeepPartial<DroppedBundle>, I>>(object: I): DroppedBundle;
};
export declare const Finalized: {
    encode(_: Finalized, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Finalized;
    fromJSON(_: any): Finalized;
    toJSON(_: Finalized): unknown;
    create<I extends Exact<DeepPartial<Finalized>, I>>(base?: I): Finalized;
    fromPartial<I extends Exact<DeepPartial<Finalized>, I>>(_: I): Finalized;
};
export declare const Processed: {
    encode(message: Processed, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Processed;
    fromJSON(object: any): Processed;
    toJSON(message: Processed): unknown;
    create<I extends Exact<DeepPartial<Processed>, I>>(base?: I): Processed;
    fromPartial<I extends Exact<DeepPartial<Processed>, I>>(object: I): Processed;
};
export declare const Dropped: {
    encode(message: Dropped, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Dropped;
    fromJSON(object: any): Dropped;
    toJSON(message: Dropped): unknown;
    create<I extends Exact<DeepPartial<Dropped>, I>>(base?: I): Dropped;
    fromPartial<I extends Exact<DeepPartial<Dropped>, I>>(object: I): Dropped;
};
export declare const BundleResult: {
    encode(message: BundleResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BundleResult;
    fromJSON(object: any): BundleResult;
    toJSON(message: BundleResult): unknown;
    create<I extends Exact<DeepPartial<BundleResult>, I>>(base?: I): BundleResult;
    fromPartial<I extends Exact<DeepPartial<BundleResult>, I>>(object: I): BundleResult;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
