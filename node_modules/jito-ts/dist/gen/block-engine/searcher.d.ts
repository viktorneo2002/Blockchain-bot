import { CallOptions, ChannelCredentials, Client, ClientOptions, ClientReadableStream, ClientUnaryCall, handleServerStreamingCall, handleUnaryCall, Metadata, ServiceError, UntypedServiceImplementation } from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { Bundle, BundleResult } from "./bundle";
export declare const protobufPackage = "searcher";
export interface SlotList {
    slots: number[];
}
export interface ConnectedLeadersResponse {
    /** Mapping of validator pubkey to leader slots for the current epoch. */
    connectedValidators: {
        [key: string]: SlotList;
    };
}
export interface ConnectedLeadersResponse_ConnectedValidatorsEntry {
    key: string;
    value: SlotList | undefined;
}
export interface SendBundleRequest {
    bundle: Bundle | undefined;
}
export interface SendBundleResponse {
    /** server uuid for the bundle */
    uuid: string;
}
export interface NextScheduledLeaderRequest {
    /** Defaults to the currently connected region if no region provided. */
    regions: string[];
}
export interface NextScheduledLeaderResponse {
    /** the current slot the backend is on */
    currentSlot: number;
    /** the slot of the next leader */
    nextLeaderSlot: number;
    /** the identity pubkey (base58) of the next leader */
    nextLeaderIdentity: string;
    /** the block engine region of the next leader */
    nextLeaderRegion: string;
}
export interface ConnectedLeadersRequest {
}
export interface ConnectedLeadersRegionedRequest {
    /** Defaults to the currently connected region if no region provided. */
    regions: string[];
}
export interface ConnectedLeadersRegionedResponse {
    connectedValidators: {
        [key: string]: ConnectedLeadersResponse;
    };
}
export interface ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry {
    key: string;
    value: ConnectedLeadersResponse | undefined;
}
export interface GetTipAccountsRequest {
}
export interface GetTipAccountsResponse {
    accounts: string[];
}
export interface SubscribeBundleResultsRequest {
}
export interface GetRegionsRequest {
}
export interface GetRegionsResponse {
    /** The region the client is currently connected to */
    currentRegion: string;
    /**
     * Regions that are online and ready for connections
     * All regions: https://jito-labs.gitbook.io/mev/systems/connecting/mainnet
     */
    availableRegions: string[];
}
export declare const SlotList: {
    encode(message: SlotList, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SlotList;
    fromJSON(object: any): SlotList;
    toJSON(message: SlotList): unknown;
    create<I extends Exact<DeepPartial<SlotList>, I>>(base?: I): SlotList;
    fromPartial<I extends Exact<DeepPartial<SlotList>, I>>(object: I): SlotList;
};
export declare const ConnectedLeadersResponse: {
    encode(message: ConnectedLeadersResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConnectedLeadersResponse;
    fromJSON(object: any): ConnectedLeadersResponse;
    toJSON(message: ConnectedLeadersResponse): unknown;
    create<I extends Exact<DeepPartial<ConnectedLeadersResponse>, I>>(base?: I): ConnectedLeadersResponse;
    fromPartial<I extends Exact<DeepPartial<ConnectedLeadersResponse>, I>>(object: I): ConnectedLeadersResponse;
};
export declare const ConnectedLeadersResponse_ConnectedValidatorsEntry: {
    encode(message: ConnectedLeadersResponse_ConnectedValidatorsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConnectedLeadersResponse_ConnectedValidatorsEntry;
    fromJSON(object: any): ConnectedLeadersResponse_ConnectedValidatorsEntry;
    toJSON(message: ConnectedLeadersResponse_ConnectedValidatorsEntry): unknown;
    create<I extends Exact<DeepPartial<ConnectedLeadersResponse_ConnectedValidatorsEntry>, I>>(base?: I): ConnectedLeadersResponse_ConnectedValidatorsEntry;
    fromPartial<I extends Exact<DeepPartial<ConnectedLeadersResponse_ConnectedValidatorsEntry>, I>>(object: I): ConnectedLeadersResponse_ConnectedValidatorsEntry;
};
export declare const SendBundleRequest: {
    encode(message: SendBundleRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SendBundleRequest;
    fromJSON(object: any): SendBundleRequest;
    toJSON(message: SendBundleRequest): unknown;
    create<I extends Exact<DeepPartial<SendBundleRequest>, I>>(base?: I): SendBundleRequest;
    fromPartial<I extends Exact<DeepPartial<SendBundleRequest>, I>>(object: I): SendBundleRequest;
};
export declare const SendBundleResponse: {
    encode(message: SendBundleResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SendBundleResponse;
    fromJSON(object: any): SendBundleResponse;
    toJSON(message: SendBundleResponse): unknown;
    create<I extends Exact<DeepPartial<SendBundleResponse>, I>>(base?: I): SendBundleResponse;
    fromPartial<I extends Exact<DeepPartial<SendBundleResponse>, I>>(object: I): SendBundleResponse;
};
export declare const NextScheduledLeaderRequest: {
    encode(message: NextScheduledLeaderRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NextScheduledLeaderRequest;
    fromJSON(object: any): NextScheduledLeaderRequest;
    toJSON(message: NextScheduledLeaderRequest): unknown;
    create<I extends Exact<DeepPartial<NextScheduledLeaderRequest>, I>>(base?: I): NextScheduledLeaderRequest;
    fromPartial<I extends Exact<DeepPartial<NextScheduledLeaderRequest>, I>>(object: I): NextScheduledLeaderRequest;
};
export declare const NextScheduledLeaderResponse: {
    encode(message: NextScheduledLeaderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NextScheduledLeaderResponse;
    fromJSON(object: any): NextScheduledLeaderResponse;
    toJSON(message: NextScheduledLeaderResponse): unknown;
    create<I extends Exact<DeepPartial<NextScheduledLeaderResponse>, I>>(base?: I): NextScheduledLeaderResponse;
    fromPartial<I extends Exact<DeepPartial<NextScheduledLeaderResponse>, I>>(object: I): NextScheduledLeaderResponse;
};
export declare const ConnectedLeadersRequest: {
    encode(_: ConnectedLeadersRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConnectedLeadersRequest;
    fromJSON(_: any): ConnectedLeadersRequest;
    toJSON(_: ConnectedLeadersRequest): unknown;
    create<I extends Exact<DeepPartial<ConnectedLeadersRequest>, I>>(base?: I): ConnectedLeadersRequest;
    fromPartial<I extends Exact<DeepPartial<ConnectedLeadersRequest>, I>>(_: I): ConnectedLeadersRequest;
};
export declare const ConnectedLeadersRegionedRequest: {
    encode(message: ConnectedLeadersRegionedRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConnectedLeadersRegionedRequest;
    fromJSON(object: any): ConnectedLeadersRegionedRequest;
    toJSON(message: ConnectedLeadersRegionedRequest): unknown;
    create<I extends Exact<DeepPartial<ConnectedLeadersRegionedRequest>, I>>(base?: I): ConnectedLeadersRegionedRequest;
    fromPartial<I extends Exact<DeepPartial<ConnectedLeadersRegionedRequest>, I>>(object: I): ConnectedLeadersRegionedRequest;
};
export declare const ConnectedLeadersRegionedResponse: {
    encode(message: ConnectedLeadersRegionedResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConnectedLeadersRegionedResponse;
    fromJSON(object: any): ConnectedLeadersRegionedResponse;
    toJSON(message: ConnectedLeadersRegionedResponse): unknown;
    create<I extends Exact<DeepPartial<ConnectedLeadersRegionedResponse>, I>>(base?: I): ConnectedLeadersRegionedResponse;
    fromPartial<I extends Exact<DeepPartial<ConnectedLeadersRegionedResponse>, I>>(object: I): ConnectedLeadersRegionedResponse;
};
export declare const ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry: {
    encode(message: ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry;
    fromJSON(object: any): ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry;
    toJSON(message: ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry): unknown;
    create<I extends Exact<DeepPartial<ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry>, I>>(base?: I): ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry;
    fromPartial<I extends Exact<DeepPartial<ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry>, I>>(object: I): ConnectedLeadersRegionedResponse_ConnectedValidatorsEntry;
};
export declare const GetTipAccountsRequest: {
    encode(_: GetTipAccountsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetTipAccountsRequest;
    fromJSON(_: any): GetTipAccountsRequest;
    toJSON(_: GetTipAccountsRequest): unknown;
    create<I extends Exact<DeepPartial<GetTipAccountsRequest>, I>>(base?: I): GetTipAccountsRequest;
    fromPartial<I extends Exact<DeepPartial<GetTipAccountsRequest>, I>>(_: I): GetTipAccountsRequest;
};
export declare const GetTipAccountsResponse: {
    encode(message: GetTipAccountsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetTipAccountsResponse;
    fromJSON(object: any): GetTipAccountsResponse;
    toJSON(message: GetTipAccountsResponse): unknown;
    create<I extends Exact<DeepPartial<GetTipAccountsResponse>, I>>(base?: I): GetTipAccountsResponse;
    fromPartial<I extends Exact<DeepPartial<GetTipAccountsResponse>, I>>(object: I): GetTipAccountsResponse;
};
export declare const SubscribeBundleResultsRequest: {
    encode(_: SubscribeBundleResultsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeBundleResultsRequest;
    fromJSON(_: any): SubscribeBundleResultsRequest;
    toJSON(_: SubscribeBundleResultsRequest): unknown;
    create<I extends Exact<DeepPartial<SubscribeBundleResultsRequest>, I>>(base?: I): SubscribeBundleResultsRequest;
    fromPartial<I extends Exact<DeepPartial<SubscribeBundleResultsRequest>, I>>(_: I): SubscribeBundleResultsRequest;
};
export declare const GetRegionsRequest: {
    encode(_: GetRegionsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetRegionsRequest;
    fromJSON(_: any): GetRegionsRequest;
    toJSON(_: GetRegionsRequest): unknown;
    create<I extends Exact<DeepPartial<GetRegionsRequest>, I>>(base?: I): GetRegionsRequest;
    fromPartial<I extends Exact<DeepPartial<GetRegionsRequest>, I>>(_: I): GetRegionsRequest;
};
export declare const GetRegionsResponse: {
    encode(message: GetRegionsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetRegionsResponse;
    fromJSON(object: any): GetRegionsResponse;
    toJSON(message: GetRegionsResponse): unknown;
    create<I extends Exact<DeepPartial<GetRegionsResponse>, I>>(base?: I): GetRegionsResponse;
    fromPartial<I extends Exact<DeepPartial<GetRegionsResponse>, I>>(object: I): GetRegionsResponse;
};
export type SearcherServiceService = typeof SearcherServiceService;
export declare const SearcherServiceService: {
    /**
     * Searchers can invoke this endpoint to subscribe to their respective bundle results.
     * A success result would indicate the bundle won its state auction and was submitted to the validator.
     */
    readonly subscribeBundleResults: {
        readonly path: "/searcher.SearcherService/SubscribeBundleResults";
        readonly requestStream: false;
        readonly responseStream: true;
        readonly requestSerialize: (value: SubscribeBundleResultsRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => SubscribeBundleResultsRequest;
        readonly responseSerialize: (value: BundleResult) => Buffer;
        readonly responseDeserialize: (value: Buffer) => BundleResult;
    };
    readonly sendBundle: {
        readonly path: "/searcher.SearcherService/SendBundle";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: SendBundleRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => SendBundleRequest;
        readonly responseSerialize: (value: SendBundleResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => SendBundleResponse;
    };
    /** Returns the next scheduled leader connected to the block engine. */
    readonly getNextScheduledLeader: {
        readonly path: "/searcher.SearcherService/GetNextScheduledLeader";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: NextScheduledLeaderRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => NextScheduledLeaderRequest;
        readonly responseSerialize: (value: NextScheduledLeaderResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => NextScheduledLeaderResponse;
    };
    /** Returns leader slots for connected jito validators during the current epoch. Only returns data for this region. */
    readonly getConnectedLeaders: {
        readonly path: "/searcher.SearcherService/GetConnectedLeaders";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ConnectedLeadersRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => ConnectedLeadersRequest;
        readonly responseSerialize: (value: ConnectedLeadersResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => ConnectedLeadersResponse;
    };
    /** Returns leader slots for connected jito validators during the current epoch. */
    readonly getConnectedLeadersRegioned: {
        readonly path: "/searcher.SearcherService/GetConnectedLeadersRegioned";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: ConnectedLeadersRegionedRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => ConnectedLeadersRegionedRequest;
        readonly responseSerialize: (value: ConnectedLeadersRegionedResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => ConnectedLeadersRegionedResponse;
    };
    /** Returns the tip accounts searchers shall transfer funds to for the leader to claim. */
    readonly getTipAccounts: {
        readonly path: "/searcher.SearcherService/GetTipAccounts";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: GetTipAccountsRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => GetTipAccountsRequest;
        readonly responseSerialize: (value: GetTipAccountsResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => GetTipAccountsResponse;
    };
    /** Returns region the client is directly connected to, along with all available regions */
    readonly getRegions: {
        readonly path: "/searcher.SearcherService/GetRegions";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: GetRegionsRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => GetRegionsRequest;
        readonly responseSerialize: (value: GetRegionsResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => GetRegionsResponse;
    };
};
export interface SearcherServiceServer extends UntypedServiceImplementation {
    /**
     * Searchers can invoke this endpoint to subscribe to their respective bundle results.
     * A success result would indicate the bundle won its state auction and was submitted to the validator.
     */
    subscribeBundleResults: handleServerStreamingCall<SubscribeBundleResultsRequest, BundleResult>;
    sendBundle: handleUnaryCall<SendBundleRequest, SendBundleResponse>;
    /** Returns the next scheduled leader connected to the block engine. */
    getNextScheduledLeader: handleUnaryCall<NextScheduledLeaderRequest, NextScheduledLeaderResponse>;
    /** Returns leader slots for connected jito validators during the current epoch. Only returns data for this region. */
    getConnectedLeaders: handleUnaryCall<ConnectedLeadersRequest, ConnectedLeadersResponse>;
    /** Returns leader slots for connected jito validators during the current epoch. */
    getConnectedLeadersRegioned: handleUnaryCall<ConnectedLeadersRegionedRequest, ConnectedLeadersRegionedResponse>;
    /** Returns the tip accounts searchers shall transfer funds to for the leader to claim. */
    getTipAccounts: handleUnaryCall<GetTipAccountsRequest, GetTipAccountsResponse>;
    /** Returns region the client is directly connected to, along with all available regions */
    getRegions: handleUnaryCall<GetRegionsRequest, GetRegionsResponse>;
}
export interface SearcherServiceClient extends Client {
    /**
     * Searchers can invoke this endpoint to subscribe to their respective bundle results.
     * A success result would indicate the bundle won its state auction and was submitted to the validator.
     */
    subscribeBundleResults(request: SubscribeBundleResultsRequest, options?: Partial<CallOptions>): ClientReadableStream<BundleResult>;
    subscribeBundleResults(request: SubscribeBundleResultsRequest, metadata?: Metadata, options?: Partial<CallOptions>): ClientReadableStream<BundleResult>;
    sendBundle(request: SendBundleRequest, callback: (error: ServiceError | null, response: SendBundleResponse) => void): ClientUnaryCall;
    sendBundle(request: SendBundleRequest, metadata: Metadata, callback: (error: ServiceError | null, response: SendBundleResponse) => void): ClientUnaryCall;
    sendBundle(request: SendBundleRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: SendBundleResponse) => void): ClientUnaryCall;
    /** Returns the next scheduled leader connected to the block engine. */
    getNextScheduledLeader(request: NextScheduledLeaderRequest, callback: (error: ServiceError | null, response: NextScheduledLeaderResponse) => void): ClientUnaryCall;
    getNextScheduledLeader(request: NextScheduledLeaderRequest, metadata: Metadata, callback: (error: ServiceError | null, response: NextScheduledLeaderResponse) => void): ClientUnaryCall;
    getNextScheduledLeader(request: NextScheduledLeaderRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: NextScheduledLeaderResponse) => void): ClientUnaryCall;
    /** Returns leader slots for connected jito validators during the current epoch. Only returns data for this region. */
    getConnectedLeaders(request: ConnectedLeadersRequest, callback: (error: ServiceError | null, response: ConnectedLeadersResponse) => void): ClientUnaryCall;
    getConnectedLeaders(request: ConnectedLeadersRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ConnectedLeadersResponse) => void): ClientUnaryCall;
    getConnectedLeaders(request: ConnectedLeadersRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ConnectedLeadersResponse) => void): ClientUnaryCall;
    /** Returns leader slots for connected jito validators during the current epoch. */
    getConnectedLeadersRegioned(request: ConnectedLeadersRegionedRequest, callback: (error: ServiceError | null, response: ConnectedLeadersRegionedResponse) => void): ClientUnaryCall;
    getConnectedLeadersRegioned(request: ConnectedLeadersRegionedRequest, metadata: Metadata, callback: (error: ServiceError | null, response: ConnectedLeadersRegionedResponse) => void): ClientUnaryCall;
    getConnectedLeadersRegioned(request: ConnectedLeadersRegionedRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: ConnectedLeadersRegionedResponse) => void): ClientUnaryCall;
    /** Returns the tip accounts searchers shall transfer funds to for the leader to claim. */
    getTipAccounts(request: GetTipAccountsRequest, callback: (error: ServiceError | null, response: GetTipAccountsResponse) => void): ClientUnaryCall;
    getTipAccounts(request: GetTipAccountsRequest, metadata: Metadata, callback: (error: ServiceError | null, response: GetTipAccountsResponse) => void): ClientUnaryCall;
    getTipAccounts(request: GetTipAccountsRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: GetTipAccountsResponse) => void): ClientUnaryCall;
    /** Returns region the client is directly connected to, along with all available regions */
    getRegions(request: GetRegionsRequest, callback: (error: ServiceError | null, response: GetRegionsResponse) => void): ClientUnaryCall;
    getRegions(request: GetRegionsRequest, metadata: Metadata, callback: (error: ServiceError | null, response: GetRegionsResponse) => void): ClientUnaryCall;
    getRegions(request: GetRegionsRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: GetRegionsResponse) => void): ClientUnaryCall;
}
export declare const SearcherServiceClient: {
    new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SearcherServiceClient;
    service: typeof SearcherServiceService;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
