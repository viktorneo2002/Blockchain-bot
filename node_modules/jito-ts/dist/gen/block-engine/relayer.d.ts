import { CallOptions, ChannelCredentials, Client, ClientOptions, ClientReadableStream, ClientUnaryCall, handleServerStreamingCall, handleUnaryCall, Metadata, ServiceError, UntypedServiceImplementation } from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { PacketBatch } from "./packet";
import { Header, Heartbeat, Socket } from "./shared";
export declare const protobufPackage = "relayer";
export interface GetTpuConfigsRequest {
}
export interface GetTpuConfigsResponse {
    tpu: Socket | undefined;
    tpuForward: Socket | undefined;
}
export interface SubscribePacketsRequest {
}
export interface SubscribePacketsResponse {
    header: Header | undefined;
    heartbeat?: Heartbeat | undefined;
    batch?: PacketBatch | undefined;
}
export declare const GetTpuConfigsRequest: {
    encode(_: GetTpuConfigsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetTpuConfigsRequest;
    fromJSON(_: any): GetTpuConfigsRequest;
    toJSON(_: GetTpuConfigsRequest): unknown;
    create<I extends Exact<DeepPartial<GetTpuConfigsRequest>, I>>(base?: I): GetTpuConfigsRequest;
    fromPartial<I extends Exact<DeepPartial<GetTpuConfigsRequest>, I>>(_: I): GetTpuConfigsRequest;
};
export declare const GetTpuConfigsResponse: {
    encode(message: GetTpuConfigsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetTpuConfigsResponse;
    fromJSON(object: any): GetTpuConfigsResponse;
    toJSON(message: GetTpuConfigsResponse): unknown;
    create<I extends Exact<DeepPartial<GetTpuConfigsResponse>, I>>(base?: I): GetTpuConfigsResponse;
    fromPartial<I extends Exact<DeepPartial<GetTpuConfigsResponse>, I>>(object: I): GetTpuConfigsResponse;
};
export declare const SubscribePacketsRequest: {
    encode(_: SubscribePacketsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubscribePacketsRequest;
    fromJSON(_: any): SubscribePacketsRequest;
    toJSON(_: SubscribePacketsRequest): unknown;
    create<I extends Exact<DeepPartial<SubscribePacketsRequest>, I>>(base?: I): SubscribePacketsRequest;
    fromPartial<I extends Exact<DeepPartial<SubscribePacketsRequest>, I>>(_: I): SubscribePacketsRequest;
};
export declare const SubscribePacketsResponse: {
    encode(message: SubscribePacketsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubscribePacketsResponse;
    fromJSON(object: any): SubscribePacketsResponse;
    toJSON(message: SubscribePacketsResponse): unknown;
    create<I extends Exact<DeepPartial<SubscribePacketsResponse>, I>>(base?: I): SubscribePacketsResponse;
    fromPartial<I extends Exact<DeepPartial<SubscribePacketsResponse>, I>>(object: I): SubscribePacketsResponse;
};
/**
 * / Relayers offer a TPU and TPU forward proxy for Solana validators.
 * / Validators can connect and fetch the TPU configuration for the relayer and start to advertise the
 * / relayer's information in gossip.
 * / They can also subscribe to packets which arrived on the TPU ports at the relayer
 */
export type RelayerService = typeof RelayerService;
export declare const RelayerService: {
    /**
     * The relayer has TPU and TPU forward sockets that validators can leverage.
     * A validator can fetch this config and change its TPU and TPU forward port in gossip.
     */
    readonly getTpuConfigs: {
        readonly path: "/relayer.Relayer/GetTpuConfigs";
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestSerialize: (value: GetTpuConfigsRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => GetTpuConfigsRequest;
        readonly responseSerialize: (value: GetTpuConfigsResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => GetTpuConfigsResponse;
    };
    /**
     * Validators can subscribe to packets from the relayer and receive a multiplexed signal that contains a mixture
     * of packets and heartbeats
     */
    readonly subscribePackets: {
        readonly path: "/relayer.Relayer/SubscribePackets";
        readonly requestStream: false;
        readonly responseStream: true;
        readonly requestSerialize: (value: SubscribePacketsRequest) => Buffer;
        readonly requestDeserialize: (value: Buffer) => SubscribePacketsRequest;
        readonly responseSerialize: (value: SubscribePacketsResponse) => Buffer;
        readonly responseDeserialize: (value: Buffer) => SubscribePacketsResponse;
    };
};
export interface RelayerServer extends UntypedServiceImplementation {
    /**
     * The relayer has TPU and TPU forward sockets that validators can leverage.
     * A validator can fetch this config and change its TPU and TPU forward port in gossip.
     */
    getTpuConfigs: handleUnaryCall<GetTpuConfigsRequest, GetTpuConfigsResponse>;
    /**
     * Validators can subscribe to packets from the relayer and receive a multiplexed signal that contains a mixture
     * of packets and heartbeats
     */
    subscribePackets: handleServerStreamingCall<SubscribePacketsRequest, SubscribePacketsResponse>;
}
export interface RelayerClient extends Client {
    /**
     * The relayer has TPU and TPU forward sockets that validators can leverage.
     * A validator can fetch this config and change its TPU and TPU forward port in gossip.
     */
    getTpuConfigs(request: GetTpuConfigsRequest, callback: (error: ServiceError | null, response: GetTpuConfigsResponse) => void): ClientUnaryCall;
    getTpuConfigs(request: GetTpuConfigsRequest, metadata: Metadata, callback: (error: ServiceError | null, response: GetTpuConfigsResponse) => void): ClientUnaryCall;
    getTpuConfigs(request: GetTpuConfigsRequest, metadata: Metadata, options: Partial<CallOptions>, callback: (error: ServiceError | null, response: GetTpuConfigsResponse) => void): ClientUnaryCall;
    /**
     * Validators can subscribe to packets from the relayer and receive a multiplexed signal that contains a mixture
     * of packets and heartbeats
     */
    subscribePackets(request: SubscribePacketsRequest, options?: Partial<CallOptions>): ClientReadableStream<SubscribePacketsResponse>;
    subscribePackets(request: SubscribePacketsRequest, metadata?: Metadata, options?: Partial<CallOptions>): ClientReadableStream<SubscribePacketsResponse>;
}
export declare const RelayerClient: {
    new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RelayerClient;
    service: typeof RelayerService;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
