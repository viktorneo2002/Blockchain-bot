import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "solana.storage.ConfirmedBlock";
export declare enum RewardType {
    Unspecified = 0,
    Fee = 1,
    Rent = 2,
    Staking = 3,
    Voting = 4,
    UNRECOGNIZED = -1
}
export declare function rewardTypeFromJSON(object: any): RewardType;
export declare function rewardTypeToJSON(object: RewardType): string;
export interface ConfirmedBlock {
    previousBlockhash: string;
    blockhash: string;
    parentSlot: number;
    transactions: ConfirmedTransaction[];
    rewards: Reward[];
    blockTime: UnixTimestamp | undefined;
    blockHeight: BlockHeight | undefined;
}
export interface ConfirmedTransaction {
    transaction: Transaction | undefined;
    meta: TransactionStatusMeta | undefined;
}
export interface Transaction {
    signatures: Uint8Array[];
    message: Message | undefined;
}
export interface Message {
    header: MessageHeader | undefined;
    accountKeys: Uint8Array[];
    recentBlockhash: Uint8Array;
    instructions: CompiledInstruction[];
    versioned: boolean;
    addressTableLookups: MessageAddressTableLookup[];
}
export interface MessageHeader {
    numRequiredSignatures: number;
    numReadonlySignedAccounts: number;
    numReadonlyUnsignedAccounts: number;
}
export interface MessageAddressTableLookup {
    accountKey: Uint8Array;
    writableIndexes: Uint8Array;
    readonlyIndexes: Uint8Array;
}
export interface TransactionStatusMeta {
    err: TransactionError | undefined;
    fee: number;
    preBalances: number[];
    postBalances: number[];
    innerInstructions: InnerInstructions[];
    innerInstructionsNone: boolean;
    logMessages: string[];
    logMessagesNone: boolean;
    preTokenBalances: TokenBalance[];
    postTokenBalances: TokenBalance[];
    rewards: Reward[];
    loadedWritableAddresses: Uint8Array[];
    loadedReadonlyAddresses: Uint8Array[];
    returnData: ReturnData | undefined;
    returnDataNone: boolean;
    /**
     * Sum of compute units consumed by all instructions.
     * Available since Solana v1.10.35 / v1.11.6.
     * Set to `None` for txs executed on earlier versions.
     */
    computeUnitsConsumed?: number | undefined;
}
export interface TransactionError {
    err: Uint8Array;
}
export interface InnerInstructions {
    index: number;
    instructions: InnerInstruction[];
}
export interface InnerInstruction {
    programIdIndex: number;
    accounts: Uint8Array;
    data: Uint8Array;
    /**
     * Invocation stack height of an inner instruction.
     * Available since Solana v1.14.6
     * Set to `None` for txs executed on earlier versions.
     */
    stackHeight?: number | undefined;
}
export interface CompiledInstruction {
    programIdIndex: number;
    accounts: Uint8Array;
    data: Uint8Array;
}
export interface TokenBalance {
    accountIndex: number;
    mint: string;
    uiTokenAmount: UiTokenAmount | undefined;
    owner: string;
    programId: string;
}
export interface UiTokenAmount {
    uiAmount: number;
    decimals: number;
    amount: string;
    uiAmountString: string;
}
export interface ReturnData {
    programId: Uint8Array;
    data: Uint8Array;
}
export interface Reward {
    pubkey: string;
    lamports: number;
    postBalance: number;
    rewardType: RewardType;
    commission: string;
}
export interface Rewards {
    rewards: Reward[];
}
export interface UnixTimestamp {
    timestamp: number;
}
export interface BlockHeight {
    blockHeight: number;
}
export declare const ConfirmedBlock: {
    encode(message: ConfirmedBlock, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmedBlock;
    fromJSON(object: any): ConfirmedBlock;
    toJSON(message: ConfirmedBlock): unknown;
    create<I extends Exact<DeepPartial<ConfirmedBlock>, I>>(base?: I): ConfirmedBlock;
    fromPartial<I extends Exact<DeepPartial<ConfirmedBlock>, I>>(object: I): ConfirmedBlock;
};
export declare const ConfirmedTransaction: {
    encode(message: ConfirmedTransaction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmedTransaction;
    fromJSON(object: any): ConfirmedTransaction;
    toJSON(message: ConfirmedTransaction): unknown;
    create<I extends Exact<DeepPartial<ConfirmedTransaction>, I>>(base?: I): ConfirmedTransaction;
    fromPartial<I extends Exact<DeepPartial<ConfirmedTransaction>, I>>(object: I): ConfirmedTransaction;
};
export declare const Transaction: {
    encode(message: Transaction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Transaction;
    fromJSON(object: any): Transaction;
    toJSON(message: Transaction): unknown;
    create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction;
    fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction;
};
export declare const Message: {
    encode(message: Message, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Message;
    fromJSON(object: any): Message;
    toJSON(message: Message): unknown;
    create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message;
    fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message;
};
export declare const MessageHeader: {
    encode(message: MessageHeader, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageHeader;
    fromJSON(object: any): MessageHeader;
    toJSON(message: MessageHeader): unknown;
    create<I extends Exact<DeepPartial<MessageHeader>, I>>(base?: I): MessageHeader;
    fromPartial<I extends Exact<DeepPartial<MessageHeader>, I>>(object: I): MessageHeader;
};
export declare const MessageAddressTableLookup: {
    encode(message: MessageAddressTableLookup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MessageAddressTableLookup;
    fromJSON(object: any): MessageAddressTableLookup;
    toJSON(message: MessageAddressTableLookup): unknown;
    create<I extends Exact<DeepPartial<MessageAddressTableLookup>, I>>(base?: I): MessageAddressTableLookup;
    fromPartial<I extends Exact<DeepPartial<MessageAddressTableLookup>, I>>(object: I): MessageAddressTableLookup;
};
export declare const TransactionStatusMeta: {
    encode(message: TransactionStatusMeta, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionStatusMeta;
    fromJSON(object: any): TransactionStatusMeta;
    toJSON(message: TransactionStatusMeta): unknown;
    create<I extends Exact<DeepPartial<TransactionStatusMeta>, I>>(base?: I): TransactionStatusMeta;
    fromPartial<I extends Exact<DeepPartial<TransactionStatusMeta>, I>>(object: I): TransactionStatusMeta;
};
export declare const TransactionError: {
    encode(message: TransactionError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionError;
    fromJSON(object: any): TransactionError;
    toJSON(message: TransactionError): unknown;
    create<I extends Exact<DeepPartial<TransactionError>, I>>(base?: I): TransactionError;
    fromPartial<I extends Exact<DeepPartial<TransactionError>, I>>(object: I): TransactionError;
};
export declare const InnerInstructions: {
    encode(message: InnerInstructions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InnerInstructions;
    fromJSON(object: any): InnerInstructions;
    toJSON(message: InnerInstructions): unknown;
    create<I extends Exact<DeepPartial<InnerInstructions>, I>>(base?: I): InnerInstructions;
    fromPartial<I extends Exact<DeepPartial<InnerInstructions>, I>>(object: I): InnerInstructions;
};
export declare const InnerInstruction: {
    encode(message: InnerInstruction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InnerInstruction;
    fromJSON(object: any): InnerInstruction;
    toJSON(message: InnerInstruction): unknown;
    create<I extends Exact<DeepPartial<InnerInstruction>, I>>(base?: I): InnerInstruction;
    fromPartial<I extends Exact<DeepPartial<InnerInstruction>, I>>(object: I): InnerInstruction;
};
export declare const CompiledInstruction: {
    encode(message: CompiledInstruction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompiledInstruction;
    fromJSON(object: any): CompiledInstruction;
    toJSON(message: CompiledInstruction): unknown;
    create<I extends Exact<DeepPartial<CompiledInstruction>, I>>(base?: I): CompiledInstruction;
    fromPartial<I extends Exact<DeepPartial<CompiledInstruction>, I>>(object: I): CompiledInstruction;
};
export declare const TokenBalance: {
    encode(message: TokenBalance, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TokenBalance;
    fromJSON(object: any): TokenBalance;
    toJSON(message: TokenBalance): unknown;
    create<I extends Exact<DeepPartial<TokenBalance>, I>>(base?: I): TokenBalance;
    fromPartial<I extends Exact<DeepPartial<TokenBalance>, I>>(object: I): TokenBalance;
};
export declare const UiTokenAmount: {
    encode(message: UiTokenAmount, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UiTokenAmount;
    fromJSON(object: any): UiTokenAmount;
    toJSON(message: UiTokenAmount): unknown;
    create<I extends Exact<DeepPartial<UiTokenAmount>, I>>(base?: I): UiTokenAmount;
    fromPartial<I extends Exact<DeepPartial<UiTokenAmount>, I>>(object: I): UiTokenAmount;
};
export declare const ReturnData: {
    encode(message: ReturnData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReturnData;
    fromJSON(object: any): ReturnData;
    toJSON(message: ReturnData): unknown;
    create<I extends Exact<DeepPartial<ReturnData>, I>>(base?: I): ReturnData;
    fromPartial<I extends Exact<DeepPartial<ReturnData>, I>>(object: I): ReturnData;
};
export declare const Reward: {
    encode(message: Reward, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Reward;
    fromJSON(object: any): Reward;
    toJSON(message: Reward): unknown;
    create<I extends Exact<DeepPartial<Reward>, I>>(base?: I): Reward;
    fromPartial<I extends Exact<DeepPartial<Reward>, I>>(object: I): Reward;
};
export declare const Rewards: {
    encode(message: Rewards, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Rewards;
    fromJSON(object: any): Rewards;
    toJSON(message: Rewards): unknown;
    create<I extends Exact<DeepPartial<Rewards>, I>>(base?: I): Rewards;
    fromPartial<I extends Exact<DeepPartial<Rewards>, I>>(object: I): Rewards;
};
export declare const UnixTimestamp: {
    encode(message: UnixTimestamp, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UnixTimestamp;
    fromJSON(object: any): UnixTimestamp;
    toJSON(message: UnixTimestamp): unknown;
    create<I extends Exact<DeepPartial<UnixTimestamp>, I>>(base?: I): UnixTimestamp;
    fromPartial<I extends Exact<DeepPartial<UnixTimestamp>, I>>(object: I): UnixTimestamp;
};
export declare const BlockHeight: {
    encode(message: BlockHeight, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockHeight;
    fromJSON(object: any): BlockHeight;
    toJSON(message: BlockHeight): unknown;
    create<I extends Exact<DeepPartial<BlockHeight>, I>>(base?: I): BlockHeight;
    fromPartial<I extends Exact<DeepPartial<BlockHeight>, I>>(object: I): BlockHeight;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
