use solana_program::{
    account_info::AccountInfo,
    pubkey::Pubkey,
    program_error::ProgramError,
};
use solana_sdk::signature::Keypair;
use arrayref::{array_ref, array_refs};
use borsh::{BorshDeserialize, BorshSerialize};
use std::mem::size_of;
use std::convert::TryInto;
use spl_math::uint::U256;

const ORCA_WHIRLPOOL_PROGRAM: &str = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
const RAYDIUM_V4_PROGRAM: &str = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8";
const SERUM_SWAP_PROGRAM: &str = "9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP";
const MARINADE_PROGRAM: &str = "MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD";
const LIFINITY_PROGRAM: &str = "EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S";

const BASIS_POINTS_DIVISOR: u64 = 10000;
const PRECISION_FACTOR: u128 = 1_000_000_000_000_000_000;
const MAX_SLIPPAGE_BPS: u64 = 100;
const MIN_PROFIT_BPS: u64 = 15;
const GAS_ADJUSTMENT_FACTOR: u64 = 115;

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct AmmPool {
    pub pool_type: AmmType,
    pub address: Pubkey,
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub reserve_a: u64,
    pub reserve_b: u64,
    pub fee_numerator: u64,
    pub fee_denominator: u64,
    pub amp_factor: Option<u64>,
    pub price_scale: Option<u64>,
    pub last_update_slot: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub enum AmmType {
    ConstantProduct,
    StableSwap,
    ConcentratedLiquidity,
    WeightedPool,
    Curve,
}

#[derive(Debug, Clone)]
pub struct ArbitrageOpportunity {
    pub profit: u64,
    pub input_amount: u64,
    pub path: Vec<Pubkey>,
    pub amm_types: Vec<AmmType>,
    pub expected_output: u64,
    pub gas_estimate: u64,
}

pub struct AmmFormulaExploiter {
    pools: Vec<AmmPool>,
    keypair: Keypair,
}

impl AmmFormulaExploiter {
    pub fn new(keypair: Keypair) -> Self {
        Self {
            pools: Vec::with_capacity(256),
            keypair,
        }
    }

    pub fn add_pool(&mut self, pool: AmmPool) {
        self.pools.push(pool);
    }

    pub fn find_arbitrage_opportunities(
        &self,
        token_a: &Pubkey,
        token_b: &Pubkey,
        max_input: u64,
    ) -> Vec<ArbitrageOpportunity> {
        let mut opportunities = Vec::new();
        
        let relevant_pools: Vec<&AmmPool> = self.pools.iter()
            .filter(|p| self.pool_contains_tokens(p, token_a, token_b))
            .collect();

        if relevant_pools.len() < 2 {
            return opportunities;
        }

        for i in 0..relevant_pools.len() {
            for j in i + 1..relevant_pools.len() {
                if let Some(opp) = self.calculate_two_pool_arbitrage(
                    relevant_pools[i],
                    relevant_pools[j],
                    token_a,
                    token_b,
                    max_input,
                ) {
                    if opp.profit > 0 {
                        opportunities.push(opp);
                    }
                }
            }
        }

        for path_len in 3..=5 {
            let paths = self.find_cyclic_paths(token_a, path_len);
            for path in paths {
                if let Some(opp) = self.calculate_cyclic_arbitrage(&path, max_input) {
                    if opp.profit > 0 {
                        opportunities.push(opp);
                    }
                }
            }
        }

        opportunities.sort_by(|a, b| b.profit.cmp(&a.profit));
        opportunities.truncate(10);
        opportunities
    }

    fn pool_contains_tokens(&self, pool: &AmmPool, token_a: &Pubkey, token_b: &Pubkey) -> bool {
        (pool.token_a == *token_a || pool.token_b == *token_a) &&
        (pool.token_a == *token_b || pool.token_b == *token_b)
    }

    fn calculate_two_pool_arbitrage(
        &self,
        pool1: &AmmPool,
        pool2: &AmmPool,
        token_a: &Pubkey,
        token_b: &Pubkey,
        max_input: u64,
    ) -> Option<ArbitrageOpportunity> {
        let optimal_input = self.calculate_optimal_arbitrage_amount(pool1, pool2, token_a)?;
        let input_amount = optimal_input.min(max_input);

        let output1 = self.calculate_output_amount(pool1, token_a, token_b, input_amount)?;
        let output2 = self.calculate_output_amount(pool2, token_b, token_a, output1)?;

        if output2 <= input_amount {
            return None;
        }

        let gas_estimate = self.estimate_gas_cost(&[pool1.address, pool2.address]);
        let profit_after_gas = output2.saturating_sub(input_amount).saturating_sub(gas_estimate);

        if profit_after_gas < (input_amount * MIN_PROFIT_BPS / BASIS_POINTS_DIVISOR) {
            return None;
        }

        Some(ArbitrageOpportunity {
            profit: profit_after_gas,
            input_amount,
            path: vec![pool1.address, pool2.address],
            amm_types: vec![pool1.pool_type.clone(), pool2.pool_type.clone()],
            expected_output: output2,
            gas_estimate,
        })
    }

    fn calculate_cyclic_arbitrage(
        &self,
        path: &[Pubkey],
        max_input: u64,
    ) -> Option<ArbitrageOpportunity> {
        if path.len() < 3 {
            return None;
        }

        let pools: Vec<&AmmPool> = path.iter()
            .filter_map(|addr| self.pools.iter().find(|p| p.address == *addr))
            .collect();

        if pools.len() != path.len() {
            return None;
        }

        let optimal_input = self.binary_search_optimal_cyclic_input(&pools, 1, max_input)?;
        let mut current_amount = optimal_input;
        let mut amm_types = Vec::new();

        for i in 0..pools.len() {
            let pool = pools[i];
            amm_types.push(pool.pool_type.clone());
            
            let (token_in, token_out) = if i == pools.len() - 1 {
                (&pools[0].token_a, &pools[0].token_a)
            } else {
                self.determine_token_flow(pool, pools[(i + 1) % pools.len()])?
            };

            current_amount = self.calculate_output_amount(pool, token_in, token_out, current_amount)?;
        }

        if current_amount <= optimal_input {
            return None;
        }

        let gas_estimate = self.estimate_gas_cost(path);
        let profit_after_gas = current_amount.saturating_sub(optimal_input).saturating_sub(gas_estimate);

        if profit_after_gas < (optimal_input * MIN_PROFIT_BPS / BASIS_POINTS_DIVISOR) {
            return None;
        }

        Some(ArbitrageOpportunity {
            profit: profit_after_gas,
            input_amount: optimal_input,
            path: path.to_vec(),
            amm_types,
            expected_output: current_amount,
            gas_estimate,
        })
    }

    fn calculate_output_amount(
        &self,
        pool: &AmmPool,
        token_in: &Pubkey,
        token_out: &Pubkey,
        amount_in: u64,
    ) -> Option<u64> {
        let (reserve_in, reserve_out) = if pool.token_a == *token_in {
            (pool.reserve_a, pool.reserve_b)
        } else {
            (pool.reserve_b, pool.reserve_a)
        };

        match pool.pool_type {
            AmmType::ConstantProduct => {
                self.constant_product_output(amount_in, reserve_in, reserve_out, pool.fee_numerator, pool.fee_denominator)
            }
            AmmType::StableSwap => {
                self.stable_swap_output(amount_in, reserve_in, reserve_out, pool.amp_factor?, pool.fee_numerator, pool.fee_denominator)
            }
            AmmType::ConcentratedLiquidity => {
                self.concentrated_liquidity_output(amount_in, reserve_in, reserve_out, pool.price_scale?, pool.fee_numerator, pool.fee_denominator)
            }
            AmmType::WeightedPool => {
                self.weighted_pool_output(amount_in, reserve_in, reserve_out, 50, 50, pool.fee_numerator, pool.fee_denominator)
            }
            AmmType::Curve => {
                self.curve_output(amount_in, reserve_in, reserve_out, pool.amp_factor?, pool.fee_numerator, pool.fee_denominator)
            }
        }
    }

    fn constant_product_output(
        &self,
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
        fee_num: u64,
        fee_denom: u64,
    ) -> Option<u64> {
        if reserve_in == 0 || reserve_out == 0 {
            return None;
        }

        let amount_in_with_fee = (amount_in as u128)
            .checked_mul((fee_denom - fee_num) as u128)?;
        
        let numerator = amount_in_with_fee
            .checked_mul(reserve_out as u128)?;
        
        let denominator = (reserve_in as u128)
            .checked_mul(fee_denom as u128)?
            .checked_add(amount_in_with_fee)?;

        Some((numerator / denominator) as u64)
    }

    fn stable_swap_output(
        &self,
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
        amp: u64,
        fee_num: u64,
        fee_denom: u64,
    ) -> Option<u64> {
        let d = self.calculate_stable_swap_d(reserve_in, reserve_out, amp)?;
        
        let amount_in_after_fee = amount_in
            .checked_mul(fee_denom - fee_num)?
            .checked_div(fee_denom)?;

        let new_reserve_in = reserve_in.checked_add(amount_in_after_fee)?;
        let new_reserve_out = self.calculate_stable_swap_y(new_reserve_in, d, amp)?;

        reserve_out.checked_sub(new_reserve_out)
    }

    fn concentrated_liquidity_output(
        &self,
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
        price_scale: u64,
        fee_num: u64,
        fee_denom: u64,
    ) -> Option<u64> {
        let sqrt_price = self.calculate_sqrt_price(reserve_in, reserve_out, price_scale)?;
        let liquidity = self.calculate_liquidity(reserve_in, reserve_out, sqrt_price)?;

        let amount_in_after_fee = amount_in
            .checked_mul(fee_denom - fee_num)?
            .checked_div(fee_denom)?;

        let new_sqrt_price = self.calculate_new_sqrt_price(
            sqrt_price,
            liquidity,
            amount_in_after_fee,
            true
        )?;

        let output = self.calculate_cl_output(
            sqrt_price,
            new_sqrt_price,
            liquidity
        )?;

        Some(output)
    }

    fn weighted_pool_output(
        &self,
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
        weight_in: u64,
        weight_out: u64,
        fee_num: u64,
        fee_denom: u64,
    ) -> Option<u64> {
        let amount_in_after_fee = amount_in
            .checked_mul(fee_denom - fee_num)?
            .checked_div(fee_denom)?;

        let base = PRECISION_FACTOR
            .checked_add((amount_in_after_fee as u128 * PRECISION_FACTOR) / reserve_in as u128)?;

        let exponent = (weight_in as u128 * PRECISION_FACTOR) / weight_out as u128;
        let result = self.pow_approximation(base, exponent)?;

        let output = (reserve_out as u128)
            .checked_mul(PRECISION_FACTOR - result)?
            .checked_div(PRECISION_FACTOR)?;

                Some(output as u64)
    }

    fn curve_output(
        &self,
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
        amp: u64,
        fee_num: u64,
        fee_denom: u64,
    ) -> Option<u64> {
        let amount_in_after_fee = amount_in
            .checked_mul(fee_denom - fee_num)?
            .checked_div(fee_denom)?;

        let ann = amp.checked_mul(2)?;
        let sum = reserve_in.checked_add(reserve_out)?;
        let d = self.calculate_curve_d(reserve_in, reserve_out, ann)?;

        let new_reserve_in = reserve_in.checked_add(amount_in_after_fee)?;
        let c = (d as u128).checked_pow(3)?
            .checked_div((new_reserve_in as u128).checked_mul(4)?.checked_mul(ann as u128)?)?;

        let b = new_reserve_in.checked_add(d / ann)?;
        let y = self.solve_quadratic_curve(b as u128, c)?;

        reserve_out.checked_sub(y as u64)
    }

    fn calculate_optimal_arbitrage_amount(
        &self,
        pool1: &AmmPool,
        pool2: &AmmPool,
        token_in: &Pubkey,
    ) -> Option<u64> {
        let (r1_in, r1_out) = if pool1.token_a == *token_in {
            (pool1.reserve_a, pool1.reserve_b)
        } else {
            (pool1.reserve_b, pool1.reserve_a)
        };

        let (r2_out, r2_in) = if pool2.token_a == *token_in {
            (pool2.reserve_a, pool2.reserve_b)
        } else {
            (pool2.reserve_b, pool2.reserve_a)
        };

        let f1 = (pool1.fee_denominator - pool1.fee_numerator) as u128;
        let f2 = (pool2.fee_denominator - pool2.fee_numerator) as u128;
        let d1 = pool1.fee_denominator as u128;
        let d2 = pool2.fee_denominator as u128;

        let numerator = self.isqrt(
            (r1_in as u128).checked_mul(r1_out as u128)?
                .checked_mul(r2_in as u128)?
                .checked_mul(r2_out as u128)?
                .checked_mul(f1)?
                .checked_mul(f2)?
                .checked_mul(d1)?
                .checked_mul(d2)?
        )?;

        let denominator = (r1_out as u128)
            .checked_mul(r2_out as u128)?
            .checked_mul(f1)?
            .checked_mul(f2)?;

        let optimal = numerator.checked_sub((r1_in as u128).checked_mul(d1)?.checked_mul(d2)?)?
            .checked_div(denominator)?;

        Some(optimal.min(u64::MAX as u128) as u64)
    }

    fn binary_search_optimal_cyclic_input(
        &self,
        pools: &[&AmmPool],
        min_input: u64,
        max_input: u64,
    ) -> Option<u64> {
        let mut left = min_input;
        let mut right = max_input;
        let mut best_input = 0;
        let mut best_profit = 0;

        while left <= right {
            let mid = left + (right - left) / 2;
            
            let mut current = mid;
            for i in 0..pools.len() {
                let pool = pools[i];
                let next_pool = pools[(i + 1) % pools.len()];
                let (token_in, token_out) = self.determine_token_flow(pool, next_pool)?;
                current = self.calculate_output_amount(pool, token_in, token_out, current)?;
            }

            let profit = current.saturating_sub(mid);
            
            if profit > best_profit {
                best_profit = profit;
                best_input = mid;
            }

            let mid_plus = mid.saturating_add(1);
            let mut current_plus = mid_plus;
            for i in 0..pools.len() {
                let pool = pools[i];
                let next_pool = pools[(i + 1) % pools.len()];
                let (token_in, token_out) = self.determine_token_flow(pool, next_pool)?;
                current_plus = self.calculate_output_amount(pool, token_in, token_out, current_plus)?;
            }

            let profit_plus = current_plus.saturating_sub(mid_plus);

            if profit_plus > profit {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        if best_profit > 0 {
            Some(best_input)
        } else {
            None
        }
    }

    fn determine_token_flow(&self, pool1: &AmmPool, pool2: &AmmPool) -> Option<(&Pubkey, &Pubkey)> {
        if pool1.token_b == pool2.token_a {
            Some((&pool1.token_a, &pool1.token_b))
        } else if pool1.token_a == pool2.token_a {
            Some((&pool1.token_b, &pool1.token_a))
        } else if pool1.token_b == pool2.token_b {
            Some((&pool1.token_a, &pool1.token_b))
        } else if pool1.token_a == pool2.token_b {
            Some((&pool1.token_b, &pool1.token_a))
        } else {
            None
        }
    }

    fn find_cyclic_paths(&self, start_token: &Pubkey, length: usize) -> Vec<Vec<Pubkey>> {
        let mut paths = Vec::new();
        let mut current_path = Vec::new();
        let mut visited = vec![false; self.pools.len()];

        self.dfs_cyclic_paths(
            start_token,
            start_token,
            length,
            &mut current_path,
            &mut visited,
            &mut paths,
        );

        paths
    }

    fn dfs_cyclic_paths(
        &self,
        current_token: &Pubkey,
        start_token: &Pubkey,
        remaining_length: usize,
        current_path: &mut Vec<Pubkey>,
        visited: &mut Vec<bool>,
        paths: &mut Vec<Vec<Pubkey>>,
    ) {
        if remaining_length == 0 {
            if current_token == start_token && current_path.len() >= 3 {
                paths.push(current_path.clone());
            }
            return;
        }

        for (idx, pool) in self.pools.iter().enumerate() {
            if !visited[idx] && (pool.token_a == *current_token || pool.token_b == *current_token) {
                visited[idx] = true;
                current_path.push(pool.address);

                let next_token = if pool.token_a == *current_token {
                    &pool.token_b
                } else {
                    &pool.token_a
                };

                self.dfs_cyclic_paths(
                    next_token,
                    start_token,
                    remaining_length - 1,
                    current_path,
                    visited,
                    paths,
                );

                current_path.pop();
                visited[idx] = false;
            }
        }
    }

    fn calculate_stable_swap_d(&self, x: u64, y: u64, amp: u64) -> Option<u64> {
        let sum = x.checked_add(y)?;
        if sum == 0 {
            return Some(0);
        }

        let mut d = sum;
        let ann = amp.checked_mul(2)?;

        for _ in 0..255 {
            let d_squared = (d as u128).checked_mul(d as u128)?;
            let d_cubed = d_squared.checked_mul(d as u128)?;
            
            let numerator = d_cubed;
            let denominator = (2u128)
                .checked_mul(x as u128)?
                .checked_mul(y as u128)?
                .checked_mul(ann as u128)?;

            if denominator == 0 {
                break;
            }

            let k = numerator.checked_div(denominator)?;
            let d_prev = d;

            d = ((ann as u128).checked_mul(sum as u128)?
                .checked_add(2u128.checked_mul(k)?))?
                .checked_mul(d as u128)?
                .checked_div(
                    (ann as u128).checked_sub(1)?
                        .checked_mul(d as u128)?
                        .checked_add(3u128.checked_mul(k)?)?
                )? as u64;

            if d > d_prev && d - d_prev <= 1 || d_prev > d && d_prev - d <= 1 {
                break;
            }
        }

        Some(d)
    }

    fn calculate_stable_swap_y(&self, x: u64, d: u64, amp: u64) -> Option<u64> {
        let ann = amp.checked_mul(2)?;
        let c = (d as u128).checked_pow(3)?
            .checked_div((x as u128).checked_mul(ann as u128)?.checked_mul(2)?)?;

        let b = x.checked_add(d.checked_div(ann)?)?;
        let mut y = d;

        for _ in 0..255 {
            let y_prev = y;
            let y_squared = (y as u128).checked_mul(y as u128)?;

            y = y_squared
                .checked_add(c)?
                .checked_div(
                    (2u128).checked_mul(y as u128)?
                        .checked_add(b as u128)?
                        .checked_sub(d as u128)?
                )? as u64;

            if y > y_prev && y - y_prev <= 1 || y_prev > y && y_prev - y <= 1 {
                break;
            }
        }

        Some(y)
    }

    fn calculate_sqrt_price(&self, reserve0: u64, reserve1: u64, price_scale: u64) -> Option<u64> {
        let ratio = ((reserve1 as u128).checked_mul(PRECISION_FACTOR)?
            .checked_div(reserve0 as u128)?
            .checked_mul(price_scale as u128)?
            .checked_div(PRECISION_FACTOR)?) as u64;

        Some(self.isqrt(ratio as u128)? as u64)
    }

    fn calculate_liquidity(&self, reserve0: u64, reserve1: u64, sqrt_price: u64) -> Option<u64> {
        let l0 = (reserve0 as u128).checked_mul(sqrt_price as u128)?;
        let l1 = (reserve1 as u128).checked_mul(PRECISION_FACTOR)?
            .checked_div(sqrt_price as u128)?;

        Some(l0.min(l1) as u64)
    }

    fn calculate_new_sqrt_price(
        &self,
        current_sqrt_price: u64,
        liquidity: u64,
        amount: u64,
        zero_for_one: bool,
    ) -> Option<u64> {
        if zero_for_one {
            let delta = (amount as u128).checked_mul(PRECISION_FACTOR)?
                .checked_div(liquidity as u128)?;
            
            Some(current_sqrt_price.saturating_sub(delta as u64))
        } else {
            let delta = (amount as u128).checked_mul(current_sqrt_price as u128)?
                .checked_div(liquidity as u128)?;
            
            Some(current_sqrt_price.checked_add(delta as u64)?)
        }
    }

    fn calculate_cl_output(
        &self,
        sqrt_price_start: u64,
        sqrt_price_end: u64,
        liquidity: u64,
    ) -> Option<u64> {
        let delta = sqrt_price_start.abs_diff(sqrt_price_end);
        
        ((liquidity as u128).checked_mul(delta as u128)?
            .checked_div(PRECISION_FACTOR)?) as u64
            .into()
    }

    fn calculate_curve_d(&self, x: u64, y: u64, ann: u64) -> Option<u64> {
        self.calculate_stable_swap_d(x, y, ann / 2)
    }

    fn solve_quadratic_curve(&self, b: u128, c: u128) -> Option<u128> {
        let discriminant = b.checked_pow(2)?.checked_sub(4u128.checked_mul(c)?)?;
        let sqrt_disc = self.isqrt(discriminant)?;
        
        b.checked_add(sqrt_disc)?.checked_div(2)
    }

    fn pow_approximation(&self, base: u128, exponent: u128) -> Option<u128> {
        if exponent == 0 {
            return Some(PRECISION_FACTOR);
        }
        
        if exponent == PRECISION_FACTOR {
            return Some(base);
        }

        let ln_base = self.ln_approximation(base)?;
        let result = (ln_base.checked_mul(exponent)?.checked_div(PRECISION_FACTOR))?;
        
        self.exp_approximation(result)
    }

    fn ln_approximation(&self, x: u128) -> Option<u128> {
        if x <= PRECISION_FACTOR {
            return Some(0);
        }

        let mut result = 0u128;
        let mut y = x;
        let mut power = PRECISION_FACTOR;

        for i in 0..40 {
            power = power.checked_mul(power)?.checked_div(PRECISION_FACTOR)?;
            if y >= power {
                y = y.checked_mul(PRECISION_FACTOR)?.checked_div(power)?;
                result = result.checked_add(PRECISION_FACTOR >> (i + 1))?;
            }
        }

        Some(result)
    }

    fn exp_approximation(&self, x: u128) -> Option<u128> {
        let mut result = PRECISION_FACTOR;
        let mut term = PRECISION_FACTOR;

        for i in 1..20 {
            term = term.checked_mul(x)?.checked_div(i as u128)?.checked_div(PRECISION_FACTOR)?;
            result = result.checked_add(term)?;
            
            if term < 1000 {
                break;
            }
        }

                Some(result)
    }

    fn isqrt(&self, n: u128) -> Option<u128> {
        if n == 0 {
            return Some(0);
        }

        let mut x = n;
        let mut y = (x + 1) / 2;

        while y < x {
            x = y;
            y = (x + n / x) / 2;
        }

        Some(x)
    }

    fn estimate_gas_cost(&self, pools: &[Pubkey]) -> u64 {
        let base_cost = 5000;
        let per_pool_cost = 25000;
        let compute_units = base_cost + (pools.len() as u64 * per_pool_cost);
        
        compute_units * GAS_ADJUSTMENT_FACTOR / 100
    }

    pub fn validate_opportunity(&self, opportunity: &ArbitrageOpportunity) -> Result<bool, ProgramError> {
        if opportunity.profit == 0 {
            return Ok(false);
        }

        if opportunity.input_amount == 0 || opportunity.input_amount > u64::MAX / 2 {
            return Ok(false);
        }

        if opportunity.path.is_empty() || opportunity.path.len() > 6 {
            return Ok(false);
        }

        let min_profit_threshold = opportunity.input_amount
            .saturating_mul(MIN_PROFIT_BPS)
            .saturating_div(BASIS_POINTS_DIVISOR);

        if opportunity.profit < min_profit_threshold {
            return Ok(false);
        }

        let profit_ratio = opportunity.profit
            .saturating_mul(BASIS_POINTS_DIVISOR)
            .saturating_div(opportunity.input_amount);

        if profit_ratio > 5000 {
            return Ok(false);
        }

        Ok(true)
    }

    pub fn calculate_slippage_adjusted_amount(&self, amount: u64, is_input: bool) -> u64 {
        if is_input {
            amount.saturating_mul(BASIS_POINTS_DIVISOR + MAX_SLIPPAGE_BPS)
                .saturating_div(BASIS_POINTS_DIVISOR)
        } else {
            amount.saturating_mul(BASIS_POINTS_DIVISOR - MAX_SLIPPAGE_BPS)
                .saturating_div(BASIS_POINTS_DIVISOR)
        }
    }

    pub fn update_pool_reserves(
        &mut self,
        pool_address: &Pubkey,
        new_reserve_a: u64,
        new_reserve_b: u64,
        slot: u64,
    ) -> Result<(), ProgramError> {
        if let Some(pool) = self.pools.iter_mut().find(|p| p.address == *pool_address) {
            pool.reserve_a = new_reserve_a;
            pool.reserve_b = new_reserve_b;
            pool.last_update_slot = slot;
            Ok(())
        } else {
            Err(ProgramError::InvalidAccountData)
        }
    }

    pub fn get_pool_by_address(&self, address: &Pubkey) -> Option<&AmmPool> {
        self.pools.iter().find(|p| p.address == *address)
    }

    pub fn calculate_price_impact(
        &self,
        pool: &AmmPool,
        token_in: &Pubkey,
        amount_in: u64,
    ) -> Option<u64> {
        let (reserve_in, reserve_out) = if pool.token_a == *token_in {
            (pool.reserve_a, pool.reserve_b)
        } else {
            (pool.reserve_b, pool.reserve_a)
        };

        let spot_price = (reserve_out as u128)
            .checked_mul(PRECISION_FACTOR)?
            .checked_div(reserve_in as u128)?;

        let output = self.calculate_output_amount(pool, token_in, 
            if pool.token_a == *token_in { &pool.token_b } else { &pool.token_a }, 
            amount_in)?;

        let effective_price = (output as u128)
            .checked_mul(PRECISION_FACTOR)?
            .checked_div(amount_in as u128)?;

        let price_impact = spot_price
            .saturating_sub(effective_price)
            .checked_mul(BASIS_POINTS_DIVISOR as u128)?
            .checked_div(spot_price)?;

        Some(price_impact as u64)
    }

    pub fn filter_profitable_opportunities(
        &self,
        opportunities: Vec<ArbitrageOpportunity>,
        min_profit: u64,
    ) -> Vec<ArbitrageOpportunity> {
        opportunities.into_iter()
            .filter(|opp| {
                opp.profit >= min_profit &&
                self.validate_opportunity(opp).unwrap_or(false)
            })
            .collect()
    }

    pub fn rank_opportunities(
        &self,
        opportunities: &mut Vec<ArbitrageOpportunity>,
    ) {
        opportunities.sort_by(|a, b| {
            let a_score = self.calculate_opportunity_score(a);
            let b_score = self.calculate_opportunity_score(b);
            b_score.cmp(&a_score)
        });
    }

    fn calculate_opportunity_score(&self, opportunity: &ArbitrageOpportunity) -> u64 {
        let profit_weight = 70;
        let success_weight = 20;
        let gas_weight = 10;

        let profit_score = opportunity.profit
            .saturating_mul(profit_weight)
            .saturating_div(opportunity.input_amount.max(1));

        let path_length_penalty = (opportunity.path.len() as u64).saturating_sub(2);
        let success_score = (100u64.saturating_sub(path_length_penalty * 10))
            .saturating_mul(success_weight)
            .saturating_div(100);

        let gas_efficiency = if opportunity.gas_estimate > 0 {
            opportunity.profit
                .saturating_mul(100)
                .saturating_div(opportunity.gas_estimate)
                .min(100)
        } else {
            0
        };

        let gas_score = gas_efficiency
            .saturating_mul(gas_weight)
            .saturating_div(100);

        profit_score
            .saturating_add(success_score)
            .saturating_add(gas_score)
    }

    pub fn simulate_arbitrage_execution(
        &self,
        opportunity: &ArbitrageOpportunity,
    ) -> Result<u64, ProgramError> {
        let mut current_amount = opportunity.input_amount;
        
        for (i, pool_address) in opportunity.path.iter().enumerate() {
            let pool = self.get_pool_by_address(pool_address)
                .ok_or(ProgramError::InvalidAccountData)?;

            let next_pool_address = &opportunity.path[(i + 1) % opportunity.path.len()];
            let next_pool = self.get_pool_by_address(next_pool_address)
                .ok_or(ProgramError::InvalidAccountData)?;

            let (token_in, token_out) = self.determine_token_flow(pool, next_pool)
                .ok_or(ProgramError::InvalidArgument)?;

            current_amount = self.calculate_output_amount(pool, token_in, token_out, current_amount)
                .ok_or(ProgramError::InvalidArgument)?;

            current_amount = self.calculate_slippage_adjusted_amount(current_amount, false);
        }

        Ok(current_amount)
    }

    pub fn get_pool_stats(&self) -> (usize, u64, u64) {
        let total_pools = self.pools.len();
        let total_liquidity_a: u64 = self.pools.iter()
            .map(|p| p.reserve_a)
            .fold(0u64, |acc, r| acc.saturating_add(r));
        let total_liquidity_b: u64 = self.pools.iter()
            .map(|p| p.reserve_b)
            .fold(0u64, |acc, r| acc.saturating_add(r));

        (total_pools, total_liquidity_a, total_liquidity_b)
    }

    pub fn clean_stale_pools(&mut self, current_slot: u64, max_age: u64) {
        self.pools.retain(|pool| {
            current_slot.saturating_sub(pool.last_update_slot) <= max_age
        });
    }

    pub fn find_best_opportunity(
        &self,
        token_a: &Pubkey,
        token_b: &Pubkey,
        max_input: u64,
        min_profit: u64,
    ) -> Option<ArbitrageOpportunity> {
        let mut opportunities = self.find_arbitrage_opportunities(token_a, token_b, max_input);
        opportunities = self.filter_profitable_opportunities(opportunities, min_profit);
        self.rank_opportunities(&mut opportunities);
        opportunities.into_iter().next()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use solana_sdk::signature::Keypair;

    #[test]
    fn test_constant_product_formula() {
        let keypair = Keypair::new();
        let exploiter = AmmFormulaExploiter::new(keypair);
        
        let output = exploiter.constant_product_output(
            1000,
            100000,
            100000,
            30,
            10000,
        );
        
        assert!(output.is_some());
        assert!(output.unwrap() > 0);
        assert!(output.unwrap() < 1000);
    }

    #[test]
    fn test_opportunity_validation() {
        let keypair = Keypair::new();
        let exploiter = AmmFormulaExploiter::new(keypair);
        
        let opportunity = ArbitrageOpportunity {
            profit: 100,
            input_amount: 1000,
            path: vec![Pubkey::new_unique(), Pubkey::new_unique()],
            amm_types: vec![AmmType::ConstantProduct, AmmType::StableSwap],
            expected_output: 1100,
            gas_estimate: 50,
        };
        
        assert!(exploiter.validate_opportunity(&opportunity).unwrap());
    }
}

