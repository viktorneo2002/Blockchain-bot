use anyhow::{Result, anyhow};
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{
    instruction::Instruction,
    program::invoke_signed,
    system_instruction,
    sysvar::{clock::Clock, rent::Rent},
};
use anchor_spl::token::{Token, TokenAccount, Mint};
use solana_client::rpc_client::RpcClient;
use solana_client::rpc_response::RpcSimulateTransactionResult;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    compute_budget::ComputeBudgetInstruction,
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    transaction::Transaction,
    sysvar,
};
use std::collections::{HashMap, BinaryHeap};
use std::sync::{Arc, Mutex};
use std::cmp::Ordering;
use borsh::{BorshDeserialize, BorshSerialize};
use rayon::prelude::*;
use tokio;

const RAYDIUM_V4: Pubkey = solana_sdk::pubkey!("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8");
const ORCA_WHIRLPOOL: Pubkey = solana_sdk::pubkey!("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc");
const SERUM_V3: Pubkey = solana_sdk::pubkey!("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin");
const JUPITER_V4: Pubkey = solana_sdk::pubkey!("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB");

const MAX_COMPUTE_UNITS: u32 = 1_400_000;
const PRIORITY_FEE_LAMPORTS: u64 = 50_000;
const MIN_PROFIT_THRESHOLD_BPS: u64 = 15;
const MAX_SLIPPAGE_BPS: u64 = 100;
const FLASH_LOAN_FEE_BPS: u64 = 9;

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct LiquiditySource {
    pub program_id: Pubkey,
    pub pool_address: Pubkey,
    pub token_a_mint: Pubkey,
    pub token_b_mint: Pubkey,
    pub reserve_a: u64,
    pub reserve_b: u64,
    pub fee_bps: u64,
    pub last_update_slot: u64,
}

#[derive(Debug, Clone)]
pub struct ArbitragePath {
    pub profit: u64,
    pub input_amount: u64,
    pub path: Vec<LiquiditySource>,
    pub expected_output: u64,
}

impl Ord for ArbitragePath {
    fn cmp(&self, other: &Self) -> Ordering {
        self.profit.cmp(&other.profit)
    }
}

impl PartialOrd for ArbitragePath {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for ArbitragePath {
    fn eq(&self, other: &Self) -> bool {
        self.profit == other.profit
    }
}

impl Eq for ArbitragePath {}

pub struct LiquidityFragmentationExploiter {
    rpc_client: Arc<RpcClient>,
    payer: Arc<Keypair>,
    liquidity_sources: Arc<Mutex<HashMap<Pubkey, LiquiditySource>>>,
    active_opportunities: Arc<Mutex<BinaryHeap<ArbitragePath>>>,
}

impl LiquidityFragmentationExploiter {
    pub fn new(rpc_url: &str, payer: Keypair) -> Self {
        Self {
            rpc_client: Arc::new(RpcClient::new_with_commitment(
                rpc_url.to_string(),
                CommitmentConfig::processed(),
            )),
            payer: Arc::new(payer),
            liquidity_sources: Arc::new(Mutex::new(HashMap::new())),
            active_opportunities: Arc::new(Mutex::new(BinaryHeap::new())),
        }
    }

    pub async fn run(&self) -> Result<()> {
        loop {
            self.update_liquidity_sources().await?;
            self.find_arbitrage_opportunities().await?;
            
            if let Some(opportunity) = self.get_best_opportunity() {
                match self.execute_arbitrage(opportunity).await {
                    Ok(sig) => {
                        msg!("Arbitrage executed: {:?}", sig);
                    }
                    Err(e) => {
                        msg!("Arbitrage failed: {:?}", e);
                    }
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
    }

    async fn update_liquidity_sources(&self) -> Result<()> {
        let current_slot = self.rpc_client.get_slot()?;
        
        let pools = vec![
            (RAYDIUM_V4, self.fetch_raydium_pools().await?),
            (ORCA_WHIRLPOOL, self.fetch_orca_pools().await?),
            (SERUM_V3, self.fetch_serum_markets().await?),
        ];

        let mut sources = self.liquidity_sources.lock().unwrap();
        
        for (program_id, pool_list) in pools {
            for pool in pool_list {
                let mut source = pool;
                source.last_update_slot = current_slot;
                sources.insert(source.pool_address, source);
            }
        }

        Ok(())
    }

    async fn fetch_raydium_pools(&self) -> Result<Vec<LiquiditySource>> {
        let pool_accounts = self.rpc_client.get_program_accounts(&RAYDIUM_V4)?;
        
        Ok(pool_accounts.par_iter()
            .filter_map(|(pubkey, account)| {
                if account.data.len() >= 752 {
                    let pool_state = RaydiumPoolState::try_from_slice(&account.data).ok()?;
                    
                    Some(LiquiditySource {
                        program_id: RAYDIUM_V4,
                        pool_address: *pubkey,
                        token_a_mint: pool_state.token_a_mint,
                        token_b_mint: pool_state.token_b_mint,
                        reserve_a: pool_state.token_a_reserve,
                        reserve_b: pool_state.token_b_reserve,
                        fee_bps: 25,
                        last_update_slot: 0,
                    })
                } else {
                    None
                }
            })
            .collect())
    }

    async fn fetch_orca_pools(&self) -> Result<Vec<LiquiditySource>> {
        let whirlpool_accounts = self.rpc_client.get_program_accounts(&ORCA_WHIRLPOOL)?;
        
        Ok(whirlpool_accounts.par_iter()
            .filter_map(|(pubkey, account)| {
                if account.data.len() >= 653 {
                    let whirlpool = WhirlpoolState::try_from_slice(&account.data).ok()?;
                    
                    Some(LiquiditySource {
                        program_id: ORCA_WHIRLPOOL,
                        pool_address: *pubkey,
                        token_a_mint: whirlpool.token_mint_a,
                        token_b_mint: whirlpool.token_mint_b,
                        reserve_a: whirlpool.liquidity,
                        reserve_b: whirlpool.liquidity,
                        fee_bps: whirlpool.fee_rate / 100,
                        last_update_slot: 0,
                    })
                } else {
                    None
                }
            })
            .collect())
    }

    async fn fetch_serum_markets(&self) -> Result<Vec<LiquiditySource>> {
        let market_accounts = self.rpc_client.get_program_accounts(&SERUM_V3)?;
        
        Ok(market_accounts.par_iter()
            .filter_map(|(pubkey, account)| {
                if account.data.len() >= 388 {
                    let market = SerumMarketState::try_from_slice(&account.data).ok()?;
                    
                    Some(LiquiditySource {
                        program_id: SERUM_V3,
                        pool_address: *pubkey,
                        token_a_mint: market.base_mint,
                        token_b_mint: market.quote_mint,
                        reserve_a: market.base_deposits_total,
                        reserve_b: market.quote_deposits_total,
                        fee_bps: 4,
                        last_update_slot: 0,
                    })
                } else {
                    None
                }
            })
            .collect())
    }

    async fn find_arbitrage_opportunities(&self) -> Result<()> {
        let sources = self.liquidity_sources.lock().unwrap().clone();
        let token_pairs: HashMap<(Pubkey, Pubkey), Vec<LiquiditySource>> = 
            sources.values()
                .fold(HashMap::new(), |mut acc, source| {
                    let key = (source.token_a_mint.min(source.token_b_mint), 
                               source.token_a_mint.max(source.token_b_mint));
                    acc.entry(key).or_insert_with(Vec::new).push(source.clone());
                    acc
                });

        let opportunities: Vec<ArbitragePath> = token_pairs.par_iter()
            .flat_map(|(_, sources)| {
                self.calculate_arbitrage_paths(sources)
            })
            .collect();

        let mut active = self.active_opportunities.lock().unwrap();
        active.clear();
        
        for opp in opportunities {
            if opp.profit > 0 {
                active.push(opp);
            }
        }

        Ok(())
    }

    fn calculate_arbitrage_paths(&self, sources: &[LiquiditySource]) -> Vec<ArbitragePath> {
        let mut paths = Vec::new();
        
        if sources.len() < 2 {
            return paths;
        }

        for i in 0..sources.len() {
            for j in 0..sources.len() {
                if i == j {
                    continue;
                }

                let source_a = &sources[i];
                let source_b = &sources[j];

                for test_amount in [1_000_000_000u64, 5_000_000_000u64, 10_000_000_000u64] {
                    let (output_a, _) = self.calculate_swap_output(
                        test_amount,
                        source_a.reserve_a,
                        source_a.reserve_b,
                        source_a.fee_bps,
                    );

                    let (output_b, _) = self.calculate_swap_output(
                        output_a,
                        source_b.reserve_b,
                        source_b.reserve_a,
                        source_b.fee_bps,
                    );

                    let flash_loan_fee = test_amount * FLASH_LOAN_FEE_BPS / 10_000;
                    let total_cost = test_amount + flash_loan_fee;

                    if output_b > total_cost {
                        let profit = output_b - total_cost;
                        let profit_bps = profit * 10_000 / test_amount;

                        if profit_bps >= MIN_PROFIT_THRESHOLD_BPS {
                            paths.push(ArbitragePath {
                                profit,
                                input_amount: test_amount,
                                path: vec![source_a.clone(), source_b.clone()],
                                expected_output: output_b,
                            });
                        }
                    }
                }
            }
        }

        paths
    }

    fn calculate_swap_output(&self, amount_in: u64, reserve_in: u64, reserve_out: u64, fee_bps: u64) -> (u64, u64) {
        let amount_in_with_fee = amount_in * (10_000 - fee_bps) / 10_000;
        let numerator = amount_in_with_fee as u128 * reserve_out as u128;
        let denominator = reserve_in as u128 + amount_in_with_fee as u128;
        
        let amount_out = (numerator / denominator) as u64;
        let price_impact_bps = (amount_in as u128 * 10_000 / reserve_in as u128) as u64;
        
        (amount_out, price_impact_bps)
    }

    fn get_best_opportunity(&self) -> Option<ArbitragePath> {
        let mut opportunities = self.active_opportunities.lock().unwrap();
        opportunities.pop()
    }

    async fn execute_arbitrage(&self, opportunity: ArbitragePath) -> Result<String> {
        let mut instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_limit(MAX_COMPUTE_UNITS),
            ComputeBudgetInstruction::set_compute_unit_price(PRIORITY_FEE_LAMPORTS),
        ];

        instructions.push(self.build_flash_loan_instruction(&opportunity)?);

        for i in 0..opportunity.path.len() {
            let source = &opportunity.path[i];
            let amount_in = if i == 0 {
                opportunity.input_amount
            } else {
                self.calculate_intermediate_amount(&opportunity, i)
            };

            instructions.push(self.build_swap_instruction(source, amount_in)?);
        }

        instructions.push(self.build_flash_loan_repay_instruction(&opportunity)?);

        let recent_blockhash = self.rpc_client.get_latest_blockhash()?;
        let transaction = Transaction::new_signed_with_payer(
            &instructions,
            Some(&self.payer.pubkey()),
            &[&*self.payer],
            recent_blockhash,
        );

        let signature = self.rpc_client.send_and_confirm_transaction(&transaction)?;
        Ok(signature.to_string())
    }

        fn calculate_intermediate_amount(&self, opportunity: &ArbitragePath, index: usize) -> u64 {
        let mut amount = opportunity.input_amount;
        
        for i in 0..index {
            let source = &opportunity.path[i];
            let (output, _) = self.calculate_swap_output(
                amount,
                source.reserve_a,
                source.reserve_b,
                source.fee_bps,
            );
            amount = output;
        }
        
        amount
    }

    fn build_flash_loan_instruction(&self, opportunity: &ArbitragePath) -> Result<Instruction> {
        let token_mint = opportunity.path[0].token_a_mint;
        let (flash_loan_vault, _) = Pubkey::find_program_address(
            &[b"flash_loan", token_mint.as_ref()],
            &JUPITER_V4,
        );

        let data = FlashLoanInstruction::Borrow {
            amount: opportunity.input_amount,
        }.try_to_vec()?;

        Ok(Instruction {
            program_id: JUPITER_V4,
            accounts: vec![
                AccountMeta::new(self.payer.pubkey(), true),
                AccountMeta::new(flash_loan_vault, false),
                AccountMeta::new_readonly(token_mint, false),
                AccountMeta::new_readonly(anchor_spl::token::ID, false),
            ],
            data,
        })
    }

    fn build_swap_instruction(&self, source: &LiquiditySource, amount_in: u64) -> Result<Instruction> {
        match source.program_id {
            id if id == RAYDIUM_V4 => self.build_raydium_swap(source, amount_in),
            id if id == ORCA_WHIRLPOOL => self.build_orca_swap(source, amount_in),
            id if id == SERUM_V3 => self.build_serum_swap(source, amount_in),
            _ => Err(anyhow!("Unknown DEX program")),
        }
    }

    fn build_raydium_swap(&self, source: &LiquiditySource, amount_in: u64) -> Result<Instruction> {
        let (authority, _) = Pubkey::find_program_address(
            &[&source.pool_address.to_bytes()],
            &RAYDIUM_V4,
        );

        let (vault_a, _) = Pubkey::find_program_address(
            &[b"vault_a", &source.pool_address.to_bytes()],
            &RAYDIUM_V4,
        );

        let (vault_b, _) = Pubkey::find_program_address(
            &[b"vault_b", &source.pool_address.to_bytes()],
            &RAYDIUM_V4,
        );

        let user_token_a = get_associated_token_address(&self.payer.pubkey(), &source.token_a_mint);
        let user_token_b = get_associated_token_address(&self.payer.pubkey(), &source.token_b_mint);

        let data = RaydiumSwapInstruction {
            instruction: 9,
            amount_in,
            minimum_amount_out: amount_in * (10_000 - MAX_SLIPPAGE_BPS) / 10_000,
        }.try_to_vec()?;

        Ok(Instruction {
            program_id: RAYDIUM_V4,
            accounts: vec![
                AccountMeta::new_readonly(anchor_spl::token::ID, false),
                AccountMeta::new(source.pool_address, false),
                AccountMeta::new_readonly(authority, false),
                AccountMeta::new(vault_a, false),
                AccountMeta::new(vault_b, false),
                AccountMeta::new(user_token_a, false),
                AccountMeta::new(user_token_b, false),
                AccountMeta::new_readonly(self.payer.pubkey(), true),
            ],
            data,
        })
    }

    fn build_orca_swap(&self, source: &LiquiditySource, amount_in: u64) -> Result<Instruction> {
        let (tick_array_0, _) = Pubkey::find_program_address(
            &[b"tick_array", &source.pool_address.to_bytes(), &0i32.to_le_bytes()],
            &ORCA_WHIRLPOOL,
        );

        let (tick_array_1, _) = Pubkey::find_program_address(
            &[b"tick_array", &source.pool_address.to_bytes(), &1i32.to_le_bytes()],
            &ORCA_WHIRLPOOL,
        );

        let (tick_array_2, _) = Pubkey::find_program_address(
            &[b"tick_array", &source.pool_address.to_bytes(), &2i32.to_le_bytes()],
            &ORCA_WHIRLPOOL,
        );

        let vault_a = get_associated_token_address(&source.pool_address, &source.token_a_mint);
        let vault_b = get_associated_token_address(&source.pool_address, &source.token_b_mint);
        let user_token_a = get_associated_token_address(&self.payer.pubkey(), &source.token_a_mint);
        let user_token_b = get_associated_token_address(&self.payer.pubkey(), &source.token_b_mint);

        let data = OrcaSwapInstruction {
            amount: amount_in,
            other_amount_threshold: amount_in * (10_000 - MAX_SLIPPAGE_BPS) / 10_000,
            sqrt_price_limit: 0,
            amount_specified_is_input: true,
            a_to_b: true,
        }.try_to_vec()?;

        Ok(Instruction {
            program_id: ORCA_WHIRLPOOL,
            accounts: vec![
                AccountMeta::new_readonly(anchor_spl::token::ID, false),
                AccountMeta::new_readonly(self.payer.pubkey(), true),
                AccountMeta::new(source.pool_address, false),
                AccountMeta::new(user_token_a, false),
                AccountMeta::new(vault_a, false),
                AccountMeta::new(user_token_b, false),
                AccountMeta::new(vault_b, false),
                AccountMeta::new(tick_array_0, false),
                AccountMeta::new(tick_array_1, false),
                AccountMeta::new(tick_array_2, false),
            ],
            data,
        })
    }

    fn build_serum_swap(&self, source: &LiquiditySource, amount_in: u64) -> Result<Instruction> {
        let (market_authority, _) = Pubkey::find_program_address(
            &[&source.pool_address.to_bytes()],
            &SERUM_V3,
        );

        let (event_queue, _) = Pubkey::find_program_address(
            &[b"event_queue", &source.pool_address.to_bytes()],
            &SERUM_V3,
        );

        let (bids, _) = Pubkey::find_program_address(
            &[b"bids", &source.pool_address.to_bytes()],
            &SERUM_V3,
        );

        let (asks, _) = Pubkey::find_program_address(
            &[b"asks", &source.pool_address.to_bytes()],
            &SERUM_V3,
        );

        let base_vault = get_associated_token_address(&market_authority, &source.token_a_mint);
        let quote_vault = get_associated_token_address(&market_authority, &source.token_b_mint);
        let user_base = get_associated_token_address(&self.payer.pubkey(), &source.token_a_mint);
        let user_quote = get_associated_token_address(&self.payer.pubkey(), &source.token_b_mint);

        let data = SerumSwapInstruction::NewOrderV3 {
            side: 0,
            limit_price: u64::MAX,
            max_base_quantity: amount_in,
            max_quote_quantity: u64::MAX,
            order_type: 2,
            client_id: 0,
            self_trade_behavior: 0,
            limit: 65535,
        }.try_to_vec()?;

        Ok(Instruction {
            program_id: SERUM_V3,
            accounts: vec![
                AccountMeta::new(source.pool_address, false),
                AccountMeta::new(self.payer.pubkey(), true),
                AccountMeta::new(user_base, false),
                AccountMeta::new(user_quote, false),
                AccountMeta::new(base_vault, false),
                AccountMeta::new(quote_vault, false),
                AccountMeta::new_readonly(anchor_spl::token::ID, false),
                AccountMeta::new_readonly(sysvar::rent::id(), false),
                AccountMeta::new(event_queue, false),
                AccountMeta::new(bids, false),
                AccountMeta::new(asks, false),
            ],
            data,
        })
    }

    fn build_flash_loan_repay_instruction(&self, opportunity: &ArbitragePath) -> Result<Instruction> {
        let token_mint = opportunity.path[0].token_a_mint;
        let (flash_loan_vault, _) = Pubkey::find_program_address(
            &[b"flash_loan", token_mint.as_ref()],
            &JUPITER_V4,
        );

        let flash_loan_fee = opportunity.input_amount * FLASH_LOAN_FEE_BPS / 10_000;
        let repay_amount = opportunity.input_amount + flash_loan_fee;

        let data = FlashLoanInstruction::Repay {
            amount: repay_amount,
        }.try_to_vec()?;

        Ok(Instruction {
            program_id: JUPITER_V4,
            accounts: vec![
                AccountMeta::new(self.payer.pubkey(), true),
                AccountMeta::new(flash_loan_vault, false),
                AccountMeta::new_readonly(token_mint, false),
                AccountMeta::new_readonly(anchor_spl::token::ID, false),
            ],
            data,
        })
    }

    pub async fn simulate_arbitrage(&self, opportunity: &ArbitragePath) -> Result<bool> {
        let simulation_result = self.simulate_transaction(opportunity).await?;
        
        if simulation_result.err.is_some() {
            return Ok(false);
        }
        
        let simulated_profit = self.extract_profit_from_logs(&simulation_result);
        Ok(simulated_profit >= opportunity.profit * 8 / 10)
    }

    async fn simulate_transaction(&self, opportunity: &ArbitragePath) -> Result<RpcSimulateTransactionResult> {
        let mut instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_limit(MAX_COMPUTE_UNITS),
            ComputeBudgetInstruction::set_compute_unit_price(PRIORITY_FEE_LAMPORTS),
        ];

        instructions.push(self.build_flash_loan_instruction(opportunity)?);
        
        for i in 0..opportunity.path.len() {
            let source = &opportunity.path[i];
            let amount_in = self.calculate_intermediate_amount(opportunity, i);
            instructions.push(self.build_swap_instruction(source, amount_in)?);
        }
        
        instructions.push(self.build_flash_loan_repay_instruction(opportunity)?);

        let recent_blockhash = self.rpc_client.get_latest_blockhash()?;
        let transaction = Transaction::new_signed_with_payer(
            &instructions,
            Some(&self.payer.pubkey()),
            &[&*self.payer],
            recent_blockhash,
        );

        self.rpc_client.simulate_transaction(&transaction)
            .map_err(|e| anyhow!("Simulation failed: {}", e))
    }

    fn extract_profit_from_logs(&self, result: &RpcSimulateTransactionResult) -> u64 {
        result.logs.as_ref()
            .and_then(|logs| {
                logs.iter()
                    .find(|log| log.contains("profit:"))
                    .and_then(|log| {
                        log.split("profit:")
                            .nth(1)
                            .and_then(|p| p.trim().parse::<u64>().ok())
                    })
            })
            .unwrap_or(0)
    }
}

fn get_associated_token_address(wallet: &Pubkey, mint: &Pubkey) -> Pubkey {
    let (address, _) = Pubkey::find_program_address(
        &[
            wallet.as_ref(),
            anchor_spl::token::ID.as_ref(),
            mint.as_ref(),
        ],
        &anchor_spl::associated_token::ID,
    );
    address
}

#[derive(BorshSerialize, BorshDeserialize)]
struct RaydiumPoolState {
    status: u64,
    nonce: u64,
    max_order: u64,
    depth: u64,
    base_decimal: u64,
    quote_decimal: u64,
    state: u64,
    reset_flag: u64,
    min_size: u64,
    vol_max_cut_ratio: u64,
    amount_wave_ratio: u64,
    base_lot_size: u64,
    quote_lot_size: u64,
    min_price_multiplier: u64,
    max_price_multiplier: u64,
    system_decimal_value: u64,
    token_a_mint: Pubkey,
    token_b_mint: Pubkey,
    pool_pc_token_account: Pubkey,
    pool_coin_token_account: Pubkey,
    lp_mint_address: Pubkey,
    open_orders: Pubkey,
    market: Pubkey,
    serum_dex: Pubkey,
    target_orders: Pubkey,
    withdraw_queue: Pubkey,
    lp_vault: Pubkey,
    owner: Pubkey,
    pnl_owner: Pubkey,
    token_a_reserve: u64,
    token_b_reserve: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct WhirlpoolState {
    whirlpools_config: Pubkey,
    whirlpool_bump: [u8; 1],
    tick_spacing: u16,
    tick_spacing_seed: [u8; 2],
    fee_rate: u16,
    protocol_fee_rate: u16,
    liquidity: u64,
    sqrt_price: u128,
    tick_current_index: i32,
    protocol_fee_owed_a: u64,
    protocol_fee_owed_b: u64,
    token_mint_a: Pubkey,
    token_vault_a: Pubkey,
    fee_growth_global_a: u128,
    token_mint_b: Pubkey,
    token_vault_b: Pubkey,
    fee_growth_global_b: u128,
    reward_last_updated_timestamp: u64,
    reward_infos: [u8; 384],
}

#[derive(BorshSerialize, BorshDeserialize)]
struct SerumMarketState {
    account_flags: u64,
    own_address: Pubkey,
    vault_signer_nonce: u64,
    base_mint: Pubkey,
    quote_mint: Pubkey,
    base_vault: Pubkey,
    base_deposits_total: u64,
    base_fees_accrued: u64,
    quote_vault: Pubkey,
    quote_deposits_total: u64,
    quote_fees_accrued: u64,
    quote_dust_threshold: u64,
    request_queue: Pubkey,
    event_queue: Pubkey,
    bids: Pubkey,
    asks: Pubkey,
    base_lot_size: u64,
    quote_lot_size: u64,
    fee_rate_bps: u64,
    referrer_rebate_accrued: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct RaydiumSwapInstruction {
    instruction: u8,
    amount_in: u64,
    minimum_amount_out: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct OrcaSwapInstruction {
    amount: u64,
    other_amount_threshold: u64,
    sqrt_price_limit: u128,
    amount_specified_is_input: bool,
    a_to_b: bool,
}

#[derive(BorshSerialize, BorshDeserialize)]
enum SerumSwapInstruction {
    NewOrderV3 {
        side: u8,
        limit_price: u64,
        max_base_quantity: u64,
        max_quote_quantity: u64,
        order_type: u8,
        client_id: u64,
        self_trade_behavior: u8,
        limit: u16,
    },
}

#[derive(BorshSerialize, BorshDeserialize)]
enum FlashLoanInstruction {
    Borrow { amount: u64 },
    Repay { amount: u64 },
}

use solana_sdk::account_info::AccountInfo;
use solana_sdk::instruction::AccountMeta;

pub struct PerformanceMetrics {
    pub opportunities_found: u64,
    pub trades_executed: u64,
    pub total_profit: u64,
    pub failed_trades: u64,
    pub average_latency_ms: u64,
}

impl PerformanceMetrics {
    pub fn new() -> Self {
        Self {
            opportunities_found: 0,
            trades_executed: 0,
            total_profit: 0,
            failed_trades: 0,
            average_latency_ms: 0,
        }
    }

    pub fn update_latency(&mut self, latency_ms: u64) {
        self.average_latency_ms = (self.average_latency_ms * self.trades_executed + latency_ms) 
            / (self.trades_executed + 1);
    }
}

impl LiquidityFragmentationExploiter {
    pub async fn run_with_metrics(&self, metrics: Arc<Mutex<PerformanceMetrics>>) -> Result<()> {
        loop {
            let start = std::time::Instant::now();
            
            self.update_liquidity_sources().await?;
            self.find_arbitrage_opportunities().await?;
            
            let opportunities_count = self.active_opportunities.lock().unwrap().len();
            metrics.lock().unwrap().opportunities_found += opportunities_count as u64;
            
            if let Some(opportunity) = self.get_best_opportunity() {
                if self.simulate_arbitrage(&opportunity).await? {
                    match self.execute_arbitrage(opportunity.clone()).await {
                        Ok(sig) => {
                            let mut m = metrics.lock().unwrap();
                            m.trades_executed += 1;
                            m.total_profit += opportunity.profit;
                            m.update_latency(start.elapsed().as_millis() as u64);
                            msg!("Arbitrage executed: {} profit: {}", sig, opportunity.profit);
                        }
                        Err(e) => {
                            metrics.lock().unwrap().failed_trades += 1;
                            msg!("Arbitrage failed: {:?}", e);
                        }
                    }
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
        }
    }

    pub fn optimize_for_mainnet(&mut self) {
        // Optimize compute units based on network congestion
        let congestion_factor = self.estimate_network_congestion();
        let priority_fee = PRIORITY_FEE_LAMPORTS * congestion_factor / 100;
        
        // Dynamic adjustment of profit threshold based on gas costs
        let min_profit = (priority_fee * 2 + 5000) * 10_000 / 1_000_000;
    }

    fn estimate_network_congestion(&self) -> u64 {
        // Get recent slot performance
        if let Ok(perf_samples) = self.rpc_client.get_recent_performance_samples(Some(10)) {
            let avg_tps = perf_samples.iter()
                .map(|s| s.num_transactions as u64 / s.sample_period_secs.max(1) as u64)
                .sum::<u64>() / perf_samples.len().max(1) as u64;
            
            // Higher TPS = more congestion = higher priority fee multiplier
            match avg_tps {
                0..=1000 => 100,
                1001..=2000 => 150,
                2001..=3000 => 200,
                _ => 300,
            }
        } else {
            150 // Default multiplier
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use solana_sdk::signature::Keypair;

    #[tokio::test]
    async fn test_arbitrage_calculation() {
        let payer = Keypair::new();
        let exploiter = LiquidityFragmentationExploiter::new(
            "https://api.mainnet-beta.solana.com",
            payer,
        );

        let source1 = LiquiditySource {
            program_id: RAYDIUM_V4,
            pool_address: Pubkey::new_unique(),
            token_a_mint: Pubkey::new_unique(),
            token_b_mint: Pubkey::new_unique(),
            reserve_a: 1_000_000_000_000,
            reserve_b: 2_000_000_000_000,
            fee_bps: 25,
            last_update_slot: 0,
        };

        let source2 = LiquiditySource {
            program_id: ORCA_WHIRLPOOL,
            pool_address: Pubkey::new_unique(),
            token_a_mint: source1.token_a_mint,
            token_b_mint: source1.token_b_mint,
            reserve_a: 1_100_000_000_000,
            reserve_b: 1_900_000_000_000,
            fee_bps: 30,
            last_update_slot: 0,
        };

        let paths = exploiter.calculate_arbitrage_paths(&[source1, source2]);
        assert!(!paths.is_empty());
    }

    #[test]
    fn test_swap_output_calculation() {
        let exploiter = LiquidityFragmentationExploiter::new(
            "https://api.mainnet-beta.solana.com",
            Keypair::new(),
        );

        let (output, impact) = exploiter.calculate_swap_output(
            1_000_000_000,
            100_000_000_000,
            200_000_000_000,
            25,
        );

        assert!(output > 0);
        assert!(output < 2_000_000_000);
        assert!(impact < 1000);
    }
}

