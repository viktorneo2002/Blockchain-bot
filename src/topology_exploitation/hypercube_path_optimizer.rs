use solana_program::{
    account_info::AccountInfo,
    pubkey::Pubkey,
    clock::Clock,
    sysvar::Sysvar,
};
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::Instruction,
    signature::Keypair,
};
use std::{
    collections::{HashMap, BinaryHeap, HashSet, VecDeque},
    cmp::{Ordering, Reverse},
    sync::{Arc, RwLock},
    time::{Duration, Instant},
};
use arrayref::{array_ref, array_refs};
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Serialize, Deserialize};
use dashmap::DashMap;
use smallvec::SmallVec;
use tracing::{info_span, Instrument};
use prometheus::{Registry, IntCounter, IntCounterVec, IntGauge, Histogram, HistogramOpts, register_int_counter, register_int_counter_vec, register_int_gauge, register_histogram};
use rayon::prelude::*;

const MAX_DIMENSION: usize = 8;
const MAX_PATH_LENGTH: usize = 7;
const CACHE_TTL_MS: u64 = 100;
const MIN_PROFIT_BPS: u64 = 3;
const MAX_SLIPPAGE_BPS: u64 = 50;
const PRIORITY_FEE_LAMPORTS: u64 = 10000;
const MAX_COMPUTE_UNITS: u32 = 1_400_000;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct HyperNode {
    pub pool_id: Pubkey,
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub pool_type: PoolType,
    pub reserves: (u64, u64),
    pub fee_bps: u16,
    pub last_update: u64,
}

#[derive(Clone)]
struct OptimizerMetrics {
    registry: Registry,
    path_search_ms: Histogram,
    edges_expanded: IntCounter,
    heap_size: IntGauge,
    inclusion_rate: IntGauge,
    cu_used: Histogram,
    tip_lamports: Histogram,
    pnl_usd: Histogram,
    slippage_bps: Histogram,
    failure_reason: IntCounterVec,
}

impl OptimizerMetrics {
    fn new() -> Arc<Self> {
        let registry = Registry::new();
        let path_search_ms = register_histogram!(HistogramOpts::new("path_search_ms", "Path search duration in ms")).unwrap();
        let edges_expanded = register_int_counter!("edges_expanded", "Number of neighbor edges expanded").unwrap();
        let heap_size = register_int_gauge!("heap_size", "Current candidate heap size").unwrap();
        let inclusion_rate = register_int_gauge!("inclusion_rate", "EWMA inclusion rate x1000").unwrap();
        let cu_used = register_histogram!(HistogramOpts::new("cu_used", "Compute units used per path")).unwrap();
        let tip_lamports = register_histogram!(HistogramOpts::new("tip_lamports", "Tip lamports used per submission")).unwrap();
        let pnl_usd = register_histogram!(HistogramOpts::new("pnl_usd", "Path PnL in USD-equivalent")).unwrap();
        let slippage_bps = register_histogram!(HistogramOpts::new("slippage_bps", "Observed slippage per edge in bps")).unwrap();
        let failure_reason = register_int_counter_vec!("failure_reason", "Failed validation reasons", & ["reason"]).unwrap();
        registry.register(Box::new(path_search_ms.clone())).ok();
        registry.register(Box::new(edges_expanded.clone())).ok();
        registry.register(Box::new(heap_size.clone())).ok();
        registry.register(Box::new(inclusion_rate.clone())).ok();
        registry.register(Box::new(cu_used.clone())).ok();
        registry.register(Box::new(tip_lamports.clone())).ok();
        registry.register(Box::new(pnl_usd.clone())).ok();
        registry.register(Box::new(slippage_bps.clone())).ok();
        registry.register(Box::new(failure_reason.clone())).ok();
        Arc::new(Self { registry, path_search_ms, edges_expanded, heap_size, inclusion_rate, cu_used, tip_lamports, pnl_usd, slippage_bps, failure_reason })
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, BorshSerialize, BorshDeserialize)]
pub enum PoolType {
    RaydiumV4,
    OrcaWhirlpool,
    SerumV3,
    MercurialStable,
    SaberStable,
    AldrinV2,
    CremaFinance,
    LifinityV2,
}

#[derive(Clone, Debug)]
pub struct PathEdge {
    pub from_index: usize,
    pub to_index: usize,
    pub amount_in: u64,
    pub amount_out: u64,
    pub price_impact: f64,
    pub gas_cost: u64,
}

#[derive(Clone, Debug)]
#[derive(Serialize, Deserialize)]
pub struct HyperPath {
    pub edges: Vec<PathEdge>,
    pub total_profit: i64,
    pub execution_probability: f64,
    pub total_gas: u64,
    pub path_hash: u64,
}

impl Ord for HyperPath {
    fn cmp(&self, other: &Self) -> Ordering {
        let self_score = (self.total_profit as f64) * self.execution_probability;
        let other_score = (other.total_profit as f64) * other.execution_probability;
        self_score.partial_cmp(&other_score).unwrap_or(Ordering::Equal)
    }
}

impl PartialOrd for HyperPath {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for HyperPath {
    fn eq(&self, other: &Self) -> bool {
        self.path_hash == other.path_hash
    }
}

impl Eq for HyperPath {}

pub struct HypercubePathOptimizer {
    graph: Arc<RwLock<HashMap<Pubkey, Vec<HyperNode>>>>,
    path_cache: Arc<DashMap<u64, (HyperPath, Instant)>>,
    adjacency_matrix: Arc<RwLock<HashMap<(Pubkey, Pubkey), Vec<HyperNode>>>>,
    // Fast per-token neighbor index to avoid O(E^2) scans in DFS
    adjacency_by_token: Arc<RwLock<HashMap<Pubkey, Vec<HyperNode>>>>,
    // Arena storage and zero-copy indices
    pool_arena: Arc<RwLock<Vec<HyperNode>>>,
    pool_index_by_id: Arc<RwLock<HashMap<Pubkey, usize>>>,
    adjacency_idx_by_token: Arc<RwLock<HashMap<Pubkey, SmallVec<[usize; 8]>>>>,
    adjacency_idx_by_pair: Arc<RwLock<HashMap<(Pubkey, Pubkey), SmallVec<[usize; 4]>>>>,
    token_prices: Arc<DashMap<Pubkey, f64>>,
    pool_liquidity: Arc<DashMap<Pubkey, u64>>,
    execution_stats: Arc<DashMap<Pubkey, ExecutionStats>>,
    leader_inclusion: Arc<DashMap<Pubkey, LeaderInclusionStats>>,
    // Optional external quoters for non-CPMM pools
    serum_quoter: Option<Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>>,
    stableswap_quoter: Option<Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>>,
    clmm_quoter: Option<Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>>,
    // Optional external instruction builders (use SDKs off-chain)
    raydium_ix_builder: Option<Arc<dyn Fn(&PathEdge, &Pubkey) -> Instruction + Send + Sync>>,
    whirlpool_ix_builder: Option<Arc<dyn Fn(&PathEdge, &Pubkey) -> Instruction + Send + Sync>>,
    serum_ix_builder: Option<Arc<dyn Fn(&PathEdge, &Pubkey) -> Instruction + Send + Sync>>,
    // Metrics
    metrics: Arc<OptimizerMetrics>,
}

#[derive(Clone, Debug, Default)]
struct ExecutionStats {
    success_count: u64,
    failure_count: u64,
    avg_slippage: f64,
    avg_gas_used: u64,
}

#[derive(Clone, Debug, Default)]
struct LeaderInclusionStats {
    attempts: u64,
    successes: u64,
    ewma_inclusion: f64, // smoothed inclusion probability
    min_tip_lamports: u64, // observed minimal tip that included
}

impl HypercubePathOptimizer {
    pub fn new() -> Self {
        Self {
            graph: Arc::new(RwLock::new(HashMap::new())),
            path_cache: Arc::new(DashMap::new()),
            adjacency_matrix: Arc::new(RwLock::new(HashMap::new())),
            adjacency_by_token: Arc::new(RwLock::new(HashMap::new())),
            pool_arena: Arc::new(RwLock::new(Vec::new())),
            pool_index_by_id: Arc::new(RwLock::new(HashMap::new())),
            adjacency_idx_by_token: Arc::new(RwLock::new(HashMap::new())),
            adjacency_idx_by_pair: Arc::new(RwLock::new(HashMap::new())),
            token_prices: Arc::new(DashMap::new()),
            pool_liquidity: Arc::new(DashMap::new()),
            execution_stats: Arc::new(DashMap::new()),
            leader_inclusion: Arc::new(DashMap::new()),
            serum_quoter: None,
            stableswap_quoter: None,
            clmm_quoter: None,
            raydium_ix_builder: None,
            whirlpool_ix_builder: None,
            serum_ix_builder: None,
            metrics: OptimizerMetrics::new(),
        }
    }

    // Optional: initialize Rayon global pool
    pub fn new_with_config(_max_paths_cache: usize, parallel_threads: usize) -> Self {
        let _ = rayon::ThreadPoolBuilder::new().num_threads(parallel_threads).build_global();
        Self::new()
    }

    pub fn add_pool(&self, node: HyperNode) {
        let mut graph = self.graph.write().unwrap();
        graph.entry(node.token_a).or_insert_with(Vec::new).push(node.clone());
        graph.entry(node.token_b).or_insert_with(Vec::new).push(node.clone());
        
        let mut adj_matrix = self.adjacency_matrix.write().unwrap();
        adj_matrix.entry((node.token_a, node.token_b))
            .or_insert_with(Vec::new)
            .push(node.clone());
        adj_matrix.entry((node.token_b, node.token_a))
            .or_insert_with(Vec::new)
            .push(node.clone());

        // Update per-token neighbors index
        let mut adj_by_token = self.adjacency_by_token.write().unwrap();
        let entry_a = adj_by_token.entry(node.token_a).or_insert_with(Vec::new);
        if !entry_a.iter().any(|n| n.pool_id == node.pool_id) {
            entry_a.push(node.clone());
        }
        let entry_b = adj_by_token.entry(node.token_b).or_insert_with(Vec::new);
        if !entry_b.iter().any(|n| n.pool_id == node.pool_id) {
            entry_b.push(node.clone());
        }

        // Arena + index maps
        let mut arena = self.pool_arena.write().unwrap();
        let mut idx_map = self.pool_index_by_id.write().unwrap();
        let idx = if let Some(&i) = idx_map.get(&node.pool_id) { i } else {
            arena.push(node.clone());
            let i = arena.len() - 1;
            idx_map.insert(node.pool_id, i);
            i
        };
        // Indexed adjacency: token->pools
        let mut adj_idx_tok = self.adjacency_idx_by_token.write().unwrap();
        adj_idx_tok.entry(node.token_a).or_insert_with(SmallVec::new).push(idx);
        adj_idx_tok.entry(node.token_b).or_insert_with(SmallVec::new).push(idx);
        // Indexed adjacency: (token_in, token_out)->pools
        let mut adj_idx_pair = self.adjacency_idx_by_pair.write().unwrap();
        adj_idx_pair.entry((node.token_a, node.token_b)).or_insert_with(SmallVec::new).push(idx);
        adj_idx_pair.entry((node.token_b, node.token_a)).or_insert_with(SmallVec::new).push(idx);
        
        self.invalidate_cache();
    }

    pub fn find_optimal_paths(
        &self,
        start_token: Pubkey,
        target_amount: u64,
        max_paths: usize,
    ) -> Vec<HyperPath> {
        let cache_key = self.compute_cache_key(&start_token, target_amount);
        
        if let Some(cached) = self.get_cached_path(cache_key) {
            return vec![cached];
        }

        let paths = self.parallel_path_search(start_token, target_amount, max_paths);
        
        if let Some(best_path) = paths.first() {
            self.cache_path(cache_key, best_path.clone());
        }
        
        paths
    }

    fn parallel_path_search(
        &self,
        start_token: Pubkey,
        target_amount: u64,
        max_paths: usize,
    ) -> Vec<HyperPath> {
        let span = info_span!("path_search", start_token = %start_token, target_amount = target_amount, max_paths = max_paths);
        let _enter = span.enter();
        let t0 = Instant::now();
        let graph = self.graph.read().unwrap();
        let adjacency = self.adjacency_matrix.read().unwrap();
        
        let mut all_paths: Vec<HyperPath> = Vec::new();
        let mut visited = HashSet::new();
        
let initial_nodes = graph.get(&start_token).cloned().unwrap_or_else(Vec::new);
        
        let paths: Vec<_> = initial_nodes
            .par_iter()
            .flat_map(|node| {
                self.dfs_with_pruning(
                    node,
                    start_token,
                    target_amount,
                    vec![],
                    &adjacency,
                    visited.clone(),
                    0,
                )
            })
            .collect();
        
        all_paths.extend(paths);
        
        let mut heap = BinaryHeap::new();
        for path in all_paths {
            if self.validate_path(&path, target_amount, start_token) {
                heap.push(path);
            }
        }
        
        let mut result = Vec::new();
        while result.len() < max_paths && !heap.is_empty() {
            self.metrics.heap_size.set(heap.len() as i64);
            if let Some(path) = heap.pop() {
                result.push(path);
            }
        }
        
        let dt = t0.elapsed().as_secs_f64() * 1000.0;
        self.metrics.path_search_ms.observe(dt);
        result
    }

    fn dfs_with_pruning(
        &self,
        current: &HyperNode,
        target_token: Pubkey,
        remaining_amount: u64,
        current_path: Vec<PathEdge>,
        adjacency: &HashMap<(Pubkey, Pubkey), Vec<HyperNode>>,
        mut visited: HashSet<Pubkey>,
        depth: usize,
    ) -> Vec<HyperPath> {
        if depth >= MAX_PATH_LENGTH {
            return vec![];
        }
        
        if visited.contains(&current.pool_id) {
            return vec![];
        }
        
        visited.insert(current.pool_id);
        
        let mut paths = Vec::new();
        
        if current.token_a == target_token || current.token_b == target_token {
            if current_path.len() >= 2 {
                if let Some(path) = self.construct_path(current_path.clone(), remaining_amount) {
                    paths.push(path);
                }
            }
        }
        
        let next_token = if current.token_a == target_token {
            current.token_b
        } else {
            current.token_a
        };
        
        // Use per-token neighbor index for O(deg) expansion
        if let Some(neighbors) = self.adjacency_by_token.read().unwrap().get(&next_token) {
            self.metrics.edges_expanded.inc_by(neighbors.len() as u64);
            for neighbor in neighbors {
                if neighbor.pool_id == current.pool_id { continue; }
                if let Some(edge) = self.create_edge(current, neighbor, remaining_amount) {
                    if self.is_profitable_edge(&edge) {
                        let mut new_path = current_path.clone();
                        new_path.push(edge.clone());
                        let sub_paths = self.dfs_with_pruning(
                            neighbor,
                            target_token,
                            edge.amount_out,
                            new_path,
                            adjacency,
                            visited.clone(),
                            depth + 1,
                        );
                        paths.extend(sub_paths);
                    }
                }
            }
        }
        
        paths
    }

    fn create_edge(&self, from: &HyperNode, to: &HyperNode, amount_in: u64) -> Option<PathEdge> {
        // Heuristic prefilter: for CPMM, bound amount relative to reserve to limit price impact
        if matches!(from.pool_type, PoolType::RaydiumV4 | PoolType::AldrinV2) {
            let reserve_in = from.reserves.0 as u128;
            if reserve_in > 0 {
                let alpha_num = (amount_in as u128) * 10;
                if alpha_num > reserve_in { return None; }
            }
        }
        let amount_out = self.calculate_swap_output(from, amount_in)?;
        let price_impact = self.calculate_price_impact(from, amount_in, amount_out);
        let gas_cost = self.estimate_gas_cost(&from.pool_type);

        // Resolve indices from pool_id map
        let idx_map = self.pool_index_by_id.read().unwrap();
        let from_idx = *idx_map.get(&from.pool_id)?;
        let to_idx = *idx_map.get(&to.pool_id)?;
        drop(idx_map);
        
        Some(PathEdge {
            from_index: from_idx,
            to_index: to_idx,
            amount_in,
            amount_out,
            price_impact,
            gas_cost,
        })
    }

    fn calculate_swap_output(&self, pool: &HyperNode, amount_in: u64) -> Option<u64> {
        match pool.pool_type {
            // Constant product AMMs
            PoolType::RaydiumV4 | PoolType::AldrinV2 => {
                let mut rin = pool.reserves.0 as u128;
                let mut rout = pool.reserves.1 as u128;
                let fee_bps = pool.fee_bps as u128;
                let out = Self::apply_cpmm_swap(&mut rin, &mut rout, amount_in as u128, fee_bps)?;
                u64::try_from(out).ok()
            }
            // Orderbook-based (Serum v3)
            PoolType::SerumV3 => self.serum_quoter.as_ref().and_then(|q| q(pool, amount_in)),
            // Stable swap pools (use stable invariant or external quoter)
            PoolType::MercurialStable | PoolType::SaberStable => self.stableswap_quoter.as_ref().and_then(|q| q(pool, amount_in)),
            // Concentrated liquidity pools require external quoting
            PoolType::OrcaWhirlpool | PoolType::CremaFinance | PoolType::LifinityV2 => self.clmm_quoter.as_ref().and_then(|q| q(pool, amount_in)),
            // Legacy fallback for other pool types until specialized curves are added
            _ => {
                let (reserve_in, reserve_out) = pool.reserves;
                if reserve_in == 0 || reserve_out == 0 || amount_in == 0 { return None; }
                let fee_bps = pool.fee_bps as u128;
                let amount_in_u = amount_in as u128;
                let reserve_in_u = reserve_in as u128;
                let reserve_out_u = reserve_out as u128;
                let amount_in_with_fee = amount_in_u
                    .checked_mul(10_000u128.checked_sub(fee_bps)?)?
                    .checked_div(10_000u128)?;
                let numerator = amount_in_with_fee.checked_mul(reserve_out_u)?;
                let denominator = reserve_in_u.checked_add(amount_in_with_fee)?;
                let out = numerator.checked_div(denominator)?;
                u64::try_from(out).ok()
            }
        }
    }

    // Constant product swap with u128 math, updating virtual reserves
    fn apply_cpmm_swap(
        reserve_in: &mut u128,
        reserve_out: &mut u128,
        amount_in: u128,
        fee_bps: u128,
    ) -> Option<u128> {
        if *reserve_in == 0 || *reserve_out == 0 || amount_in == 0 { return None; }
        let ain_f = amount_in
            .checked_mul(10_000u128.checked_sub(fee_bps)?)?
            .checked_div(10_000u128)?;
        let denom = (*reserve_in).checked_add(ain_f)?;
        let out = ain_f.checked_mul(*reserve_out)?.checked_div(denom)?;
        *reserve_in = (*reserve_in).checked_add(ain_f)?;
        *reserve_out = (*reserve_out).checked_sub(out)?;
        Some(out)
    }

    // Realized slippage vs mid-price per protocol
    fn calculate_price_impact(&self, pool: &HyperNode, amount_in: u64, amount_out: u64) -> f64 {
        if amount_in == 0 || amount_out == 0 { return 1.0; }
        // Try protocol-native mid first
        let mid: Option<f64> = match pool.pool_type {
            // CPMM mid = reserve_out / reserve_in
            PoolType::RaydiumV4 | PoolType::AldrinV2 => {
                let (rin, rout) = pool.reserves;
                if rin == 0 { None } else { Some(rout as f64 / rin as f64) }
            }
            // For orderbook and CLMM/stable, mid should come from external quoter/book mid; fallback to token price ratio if available
            _ => {
                let pa = self.token_prices.get(&pool.token_a).map(|v| *v);
                let pb = self.token_prices.get(&pool.token_b).map(|v| *v);
                match (pa, pb) {
                    (Some(va), Some(vb)) if va > 0.0 => Some(vb / va),
                    _ => None,
                }
            },
        };
        if let Some(mid_px) = mid {
            let expected_no_impact_out = (amount_in as f64) * mid_px;
            if expected_no_impact_out <= 0.0 { return 1.0; }
            let realized = amount_out as f64;
            let slip = 1.0 - (realized / expected_no_impact_out);
            return slip.clamp(0.0, 1.0);
        }
        // Fallback conservative impact when mid unavailable
        0.2
    }

    // Register external quoters
    pub fn with_raydium_ix_builder(mut self, b: Arc<dyn Fn(&PathEdge, &Pubkey) -> Instruction + Send + Sync>) -> Self {
        self.raydium_ix_builder = Some(b);
        self
    }
    pub fn with_whirlpool_ix_builder(mut self, b: Arc<dyn Fn(&PathEdge, &Pubkey) -> Instruction + Send + Sync>) -> Self {
        self.whirlpool_ix_builder = Some(b);
        self
    }
    pub fn with_serum_ix_builder(mut self, b: Arc<dyn Fn(&PathEdge, &Pubkey) -> Instruction + Send + Sync>) -> Self {
        self.serum_ix_builder = Some(b);
        self
    }
    pub fn with_stableswap_quoter(mut self, q: Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>) -> Self {
        self.stableswap_quoter = Some(q);
        self
    }
    pub fn with_clmm_quoter(mut self, q: Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>) -> Self {
        self.clmm_quoter = Some(q);
        self
    }

    // Mutable setters (if optimizer is already constructed)
    pub fn set_serum_quoter(&mut self, q: Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>) { self.serum_quoter = Some(q); }
    pub fn set_stableswap_quoter(&mut self, q: Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>) { self.stableswap_quoter = Some(q); }
    pub fn set_clmm_quoter(&mut self, q: Arc<dyn Fn(&HyperNode, u64) -> Option<u64> + Send + Sync>) { self.clmm_quoter = Some(q); }

    fn estimate_gas_cost(&self, pool_type: &PoolType) -> u64 {
        match pool_type {
            PoolType::RaydiumV4 => 65000,
            PoolType::OrcaWhirlpool => 85000,
            PoolType::SerumV3 => 120000,
            PoolType::MercurialStable => 55000,
            PoolType::SaberStable => 50000,
            PoolType::AldrinV2 => 70000,
            PoolType::CremaFinance => 60000,
            PoolType::LifinityV2 => 75000,
        }
    }

    fn is_profitable_edge(&self, edge: &PathEdge) -> bool {
        let slip_cap = (MAX_SLIPPAGE_BPS as f64 / 10_000.0);
        if edge.price_impact > slip_cap {
            return false;
        }
        // Require net positive after gas at edge level (conservative)
        let min_out = edge
            .amount_in
            .saturating_mul(10_000 + MIN_PROFIT_BPS)
            .saturating_div(10_000);
        let gas_penalty = edge.gas_cost;
        edge.amount_out.saturating_sub(gas_penalty) > min_out
    }

    fn construct_path(&self, edges: Vec<PathEdge>, initial_amount: u64) -> Option<HyperPath> {
        if edges.is_empty() {
            return None;
        }
        
        let total_gas: u64 = edges.iter().map(|e| e.gas_cost).sum();
        let final_amount = match edges.last() {
            Some(e) => e.amount_out,
            None => return None,
        };
        
        let mut total_profit = (final_amount as i64) - (initial_amount as i64) - (total_gas as i64);
        
        if total_profit <= 0 {
            return None;
        }
        
        let execution_probability = self.calculate_execution_probability(&edges);
        let path_hash = self.hash_path(&edges);
        
        Some(HyperPath {
            edges,
            total_profit,
            execution_probability,
            total_gas,
            path_hash,
        })
    }

    // Oracle sanity checks: ensure pool implied price is close to reference oracle ratio
    pub fn pool_price_deviation_ok(&self, token_a: Pubkey, token_b: Pubkey, pool_px: f64) -> bool {
        let pa = match self.token_prices.get(&token_a) { Some(v) => *v, None => return false };
        let pb = match self.token_prices.get(&token_b) { Some(v) => *v, None => return false };
        if pa <= 0.0 || pb <= 0.0 || !pool_px.is_finite() || pool_px <= 0.0 { return false; }
        let ref_px = pa / pb;
        if ref_px <= 0.0 || !ref_px.is_finite() { return false; }
        let dev = ((pool_px / ref_px) - 1.0).abs();
        dev < 0.01 // 1% threshold; make configurable as needed
    }

    // Leader inclusion tracking and tip estimation
    pub fn update_inclusion_result(&self, leader: Pubkey, tip_lamports: u64, included: bool) {
        self.leader_inclusion.entry(leader).and_modify(|st| {
            st.attempts = st.attempts.saturating_add(1);
            if included { st.successes = st.successes.saturating_add(1); }
            let p = if st.attempts > 0 { st.successes as f64 / st.attempts as f64 } else { 0.0 };
            // EWMA smoothing
            st.ewma_inclusion = 0.7 * st.ewma_inclusion + 0.3 * p;
            if included {
                st.min_tip_lamports = if st.min_tip_lamports == 0 { tip_lamports } else { st.min_tip_lamports.min(tip_lamports) };
            }
        }).or_insert_with(|| LeaderInclusionStats {
            attempts: 1,
            successes: if included { 1 } else { 0 },
            ewma_inclusion: if included { 1.0 } else { 0.0 },
            min_tip_lamports: if included { tip_lamports } else { 0 },
        });
    }

    pub fn estimate_tip_for_target_inclusion(&self, leader: Pubkey, target_prob: f64) -> u64 {
        let st = self.leader_inclusion.get(&leader).map(|v| v.clone()).unwrap_or_default();
        // Simple elasticity: if ewma < target, scale up from min_tip; else keep near min_tip
        let base = st.min_tip_lamports.max(PRIORITY_FEE_LAMPORTS);
        if st.ewma_inclusion >= target_prob { return base; }
        let deficit = (target_prob - st.ewma_inclusion).clamp(0.0, 1.0);
        let scaled = (base as f64) * (1.0 + 3.0 * deficit); // up to 4x
        (scaled.round() as u64).clamp(base, 5_000_000)
    }

    pub fn tip_ladder_for_slot(&self, leader: Pubkey) -> Vec<u64> {
        let base = self.estimate_tip_for_target_inclusion(leader, 0.6);
        let mut ladder = vec![
            base / 2,
            base,
            (base as f64 * 1.5).round() as u64,
            (base as f64 * 2.0).round() as u64,
        ];
        ladder.iter_mut().for_each(|v| *v = v.clamp(1_000, 10_000_000));
        for t in &ladder { self.metrics.tip_lamports.observe(*t as f64); }
        ladder
    }

    fn calculate_execution_probability(&self, edges: &[PathEdge]) -> f64 {
        let mut probability = 1.0;
        for edge in edges {
            let from_node = self.pool_arena.read().unwrap().get(edge.from_index).cloned();
            let pool_id = from_node.as_ref().map(|n| n.pool_id).unwrap_or(Pubkey::default());
            let stats = self.execution_stats
                .get(&pool_id)
                .map(|s| s.clone())
                .unwrap_or_default();
            let n = stats.success_count + stats.failure_count;
            // Beta(1,1) smoothing
            let success_rate = if n > 0 {
                (stats.success_count as f64 + 1.0) / (n as f64 + 2.0)
            } else { 0.95 };
            let impact_penalty = 1.0 - edge.price_impact.min(0.5);
            probability *= (success_rate * impact_penalty).clamp(0.0, 1.0);
        }
        probability.clamp(0.0, 1.0)
    }

    fn validate_path(&self, path: &HyperPath, start_amount: u64, start_token: Pubkey) -> bool {
        if path.edges.is_empty() || path.edges.len() > MAX_PATH_LENGTH {
            self.metrics.failure_reason.with_label_values(&["empty_or_too_long"]).inc();
            return false;
        }
        let mut seen_pools = HashSet::new();
        let mut amount = start_amount;
        let mut current_token = start_token;
        let arena_read = self.pool_arena.read().unwrap();
        for (idx, edge) in path.edges.iter().enumerate() {
            let from = match arena_read.get(edge.from_index) { Some(n) => n, None => { self.metrics.failure_reason.with_label_values(&["missing_from"]).inc(); return false } };
            let to = match arena_read.get(edge.to_index) { Some(n) => n, None => { self.metrics.failure_reason.with_label_values(&["missing_to"]).inc(); return false } };
            if !seen_pools.insert(from.pool_id) { return false; }
            // Ensure edge aligns with current token direction
            let (in_token, out_token) = if from.token_a == current_token {
                (from.token_a, from.token_b)
            } else if from.token_b == current_token {
                (from.token_b, from.token_a)
            } else {
                return false;
            };

            // Amount continuity and non-zero forward progress
            if edge.amount_in != amount || edge.amount_out == 0 { self.metrics.failure_reason.with_label_values(&["amount_continuity"]).inc(); return false; }

            // Slippage/impact guard consistent with global threshold
            if edge.price_impact > (MAX_SLIPPAGE_BPS as f64 / 10_000.0) { self.metrics.failure_reason.with_label_values(&["slippage_cap"]).inc(); return false; }

            // Structural continuity: the next pool must actually be able to accept the out_token
            if !(to.token_a == out_token || to.token_b == out_token) { self.metrics.failure_reason.with_label_values(&["token_continuity"]).inc(); return false; }
            if to.pool_id == from.pool_id { return false; }

            amount = edge.amount_out;
            current_token = out_token;
        }

        // Net-of-fees profitability guard: include dynamic CU cost and an estimated tip
        let cu_price = self.dynamic_cu_price_lamports();
        let compute_fee = (MAX_COMPUTE_UNITS as u64).saturating_mul(cu_price);
        let est_tip = PRIORITY_FEE_LAMPORTS; // conservative; can be replaced per-leader
        let net_profit = (path.total_profit as i128) - (compute_fee as i128) - (est_tip as i128);
        let ok = net_profit > 0 && path.execution_probability > 0.7;
        if !ok { self.metrics.failure_reason.with_label_values(&["net_profit_or_exec_prob"]).inc(); }
        ok
    }

    // Kelly sizing helper (simplified): fraction = mu / sigma^2, capped
    pub fn kelly_fraction(mu: f64, sigma2: f64, cap: f64) -> f64 {
        if sigma2 <= 0.0 { return 0.0; }
        (mu / sigma2).clamp(0.0, cap)
    }

    // Observability helpers
    pub fn metrics_registry(&self) -> Registry { self.metrics.registry.clone() }
    pub fn set_inclusion_rate(&self, rate: f64) { self.metrics.inclusion_rate.set((rate * 1000.0) as i64); }

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cpmm_invariant_non_decreasing_k() {
        let mut rin = 1_000_000u128;
        let mut rout = 2_000_000u128;
        let k0 = rin * rout;
        let out = HypercubePathOptimizer::apply_cpmm_swap(&mut rin, &mut rout, 10_000, 30).unwrap();
        assert!(out > 0);
        let k1 = rin * rout;
        assert!(k1 >= k0);
    }

    #[test]
    fn kelly_fraction_bounds() {
        let f = HypercubePathOptimizer::kelly_fraction(0.1, 0.2, 0.5);
        assert!(f >= 0.0 && f <= 0.5);
    }
}

    fn hash_path(&self, edges: &[PathEdge]) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        
        let mut hasher = DefaultHasher::new();
        for edge in edges {
            edge.from.pool_id.hash(&mut hasher);
            edge.to.pool_id.hash(&mut hasher);
        }
        hasher.finish()
    }

    fn compute_cache_key(&self, token: &Pubkey, amount: u64) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        // Bucketize by 1k lamports for better hit rate
        let bucket = amount / 1_000;
        let mut hasher = DefaultHasher::new();
        token.hash(&mut hasher);
        bucket.hash(&mut hasher);
        hasher.finish()
    }

    fn get_cached_path(&self, key: u64) -> Option<HyperPath> {
        if let Some(entry) = self.path_cache.get(&key) {
            let (path, ts) = entry.value();
            let age = Instant::now().saturating_duration_since(*ts);
            if age < Duration::from_millis(CACHE_TTL_MS) {
                return Some(path.clone());
            }
            // Expired: drop guard before removing to avoid deadlock
            drop(entry);
            self.path_cache.remove(&key);
        }
        None
    }

    fn cache_path(&self, key: u64, path: HyperPath) {
        self.path_cache.insert(key, (path, Instant::now()));
        
        if self.path_cache.len() > 10000 {
            self.cleanup_expired_cache();
        }
    }

    fn cleanup_expired_cache(&self) {
        let now = Instant::now();
        self.path_cache.retain(|_, v| now.saturating_duration_since(v.1) < Duration::from_millis(CACHE_TTL_MS * 2));
    }

    fn invalidate_cache(&self) {
        self.path_cache.clear();
    }

    pub fn update_pool_state(&self, pool_id: Pubkey, reserves: (u64, u64), slot: u64) {
        let mut graph = self.graph.write().unwrap();
        let mut adjacency = self.adjacency_matrix.write().unwrap();
        
        for nodes in graph.values_mut() {
            for node in nodes.iter_mut() {
                if node.pool_id == pool_id {
                    node.reserves = reserves;
                    node.last_update = slot;
                }
            }
        }
        
        for nodes in adjacency.values_mut() {
            for node in nodes.iter_mut() {
                if node.pool_id == pool_id {
                    node.reserves = reserves;
                    node.last_update = slot;
                }
            }
        }
        
        self.pool_liquidity.insert(pool_id, reserves.0 + reserves.1);
        self.invalidate_cache();
    }

    pub fn update_token_price(&self, token: Pubkey, price_usd: f64) {
        self.token_prices.insert(token, price_usd);
    }

    pub fn update_execution_stats(
        &self,
        pool_id: Pubkey,
        success: bool,
        slippage: f64,
        gas_used: u64,
    ) {
        self.execution_stats
            .entry(pool_id)
            .and_modify(|stats| {
                if success {
                    stats.success_count += 1;
                } else {
                    stats.failure_count += 1;
                }
                
                let total_executions = stats.success_count + stats.failure_count;
                stats.avg_slippage = (stats.avg_slippage * (total_executions - 1) as f64 + slippage) 
                    / total_executions as f64;
                stats.avg_gas_used = (stats.avg_gas_used * (total_executions - 1) + gas_used) 
                    / total_executions;
            })
            .or_insert(ExecutionStats {
                success_count: if success { 1 } else { 0 },
                failure_count: if success { 0 } else { 1 },

    pub fn generate_instructions(&self, path: &HyperPath, payer: &Pubkey) -> Vec<Instruction> {
        let span = info_span!("build_instructions", total_gas = path.total_gas, edges = path.edges.len());
        let mut instructions = vec![];
        
        instructions.push(ComputeBudgetInstruction::set_compute_unit_limit(MAX_COMPUTE_UNITS));
        let cu_price = self.dynamic_cu_price_lamports();
        self.metrics.cu_used.observe(MAX_COMPUTE_UNITS as f64);
        self.metrics.tip_lamports.observe(cu_price as f64);
        instructions.push(ComputeBudgetInstruction::set_compute_unit_price(cu_price));
        
        for edge in &path.edges {
            let swap_ix = self.create_swap_instruction(&edge, payer);
            instructions.push(swap_ix);
        }
        
        instructions
    }

    // Provide a recommended set of keys to include in an Address Lookup Table for this path.
    // Collects DEX program IDs (by pool type), pool accounts, and token mints observed along the path.
    pub fn recommended_alt_keys_for_path(&self, path: &HyperPath) -> Vec<Pubkey> {
        let mut set: HashSet<Pubkey> = HashSet::new();
        let arena = self.pool_arena.read().unwrap();
        for edge in &path.edges {
            let from = match arena.get(edge.from_index) { Some(n) => n, None => continue };
            // Pool and mints
            set.insert(from.pool_id);
            set.insert(from.token_a);
            set.insert(from.token_b);
            // Program IDs per protocol
            match from.pool_type {
                PoolType::RaydiumV4 => {
                    let raydium = Pubkey::new_from_array([
                        0x67, 0x5f, 0xc5, 0xc7, 0x6e, 0x20, 0x24, 0x7a,
                        0xd7, 0xbd, 0x48, 0x26, 0x4f, 0x9a, 0x7b, 0x7a,
                        0xca, 0xb1, 0xf4, 0x10, 0x32, 0x28, 0x9c, 0x3c,
                        0x1a, 0x26, 0xce, 0xcd, 0xf1, 0x4c, 0xf9, 0xb7
                    ]);
                    set.insert(raydium);
                }
                PoolType::OrcaWhirlpool => {
                    let whirl = Pubkey::new_from_array([
                        0x9c, 0xfb, 0x13, 0x1c, 0xae, 0x1e, 0xc6, 0xbf,
                        0x22, 0x5f, 0x76, 0x4c, 0x6e, 0x3b, 0x73, 0x5c,
                        0x95, 0xbe, 0x1f, 0x49, 0x0a, 0x7e, 0x8d, 0x0e,
                        0x7e, 0x51, 0xd7, 0x6b, 0x6a, 0xfd, 0x7f, 0x58
                    ]);
                    set.insert(whirl);
                }
                PoolType::SerumV3 => {
                    let serum = Pubkey::new_from_array([
                        0x9a, 0xf4, 0x6f, 0xe1, 0x3e, 0x23, 0x8e, 0x2e,
                        0x19, 0x71, 0xf5, 0x12, 0xab, 0x0b, 0x8c, 0x6a,
                        0x02, 0x9e, 0xdd, 0x0f, 0xb4, 0x5a, 0xdb, 0x16,
                        0xe1, 0x1e, 0xee, 0xc9, 0x87, 0x8a, 0x2c, 0xdb
                    ]);
                    set.insert(serum);
                }
                PoolType::MercurialStable => {
                    let merc = Pubkey::new_from_array([
                        0x3e, 0xc0, 0xf3, 0xa9, 0x5f, 0x82, 0xe4, 0xa3,
                        0xe4, 0x27, 0x32, 0xac, 0x73, 0x48, 0xf7, 0x73,
                        0x8d, 0x79, 0x3c, 0x4d, 0x01, 0xf9, 0x52, 0x5c,
                        0x05, 0x5d, 0xe9, 0x74, 0x1c, 0xc1, 0xca, 0xa5
                    ]);
                    set.insert(merc);
                }
                PoolType::SaberStable => {
                    let saber = Pubkey::new_from_array([
                        0x5a, 0xbe, 0xe0, 0xac, 0xef, 0xd8, 0xbc, 0xdc,
                        0x0d, 0x6f, 0x86, 0x79, 0x1e, 0xb0, 0x82, 0x7b,
                        0x68, 0x51, 0xe7, 0x31, 0x45, 0x08, 0x3f, 0x74,
                        0xbf, 0x93, 0xc5, 0x78, 0x61, 0x1a, 0x2f, 0x81
                    ]);
                    set.insert(saber);
                }
                PoolType::AldrinV2 => {
                    let aldrin = Pubkey::new_from_array([
                        0x2a, 0x1d, 0xea, 0x8e, 0x7f, 0xf1, 0xf8, 0x9a,
                        0x7d, 0x29, 0xaf, 0x4b, 0xa8, 0x42, 0xa5, 0x08,
                        0x23, 0xc5, 0x52, 0x47, 0xf5, 0xc4, 0x9c, 0xb7,
                        0x7e, 0x61, 0xf7, 0x06, 0xf9, 0xa5, 0x4f, 0xfd
                    ]);
                    set.insert(aldrin);
                }
                PoolType::CremaFinance => {
                    let crema = Pubkey::new_from_array([
                        0xce, 0x3e, 0x3a, 0x55, 0x97, 0xfb, 0x83, 0x43,
                        0xcd, 0x43, 0xf9, 0xc5, 0x6e, 0x3f, 0xea, 0x4e,
                        0xc5, 0xf1, 0xde, 0x8f, 0x3a, 0x76, 0x34, 0x1f,
                        0xae, 0xa2, 0xd1, 0x4a, 0x96, 0x6a, 0x58, 0xa3
                    ]);
                    set.insert(crema);
                }
                PoolType::LifinityV2 => {
                    let lif = Pubkey::new_from_array([
                        0x2f, 0x56, 0x36, 0x46, 0x52, 0x8f, 0xd3, 0x41,
                        0xb7, 0xa5, 0x5b, 0x66, 0x8a, 0x46, 0x7a, 0x42,
                        0x14, 0x46, 0x2f, 0x09, 0x7f, 0x17, 0x8e, 0x05,
                        0xfb, 0x7f, 0x36, 0x6e, 0x77, 0xfb, 0x48, 0x4e
                    ]);
                    set.insert(lif);
                }
            }
        }
        set.into_iter().collect()
    }

    fn create_swap_instruction(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let node = self.pool_arena.read().unwrap()[edge.from_index].clone();
        match node.pool_type {
            PoolType::RaydiumV4 => self.create_raydium_swap_ix(edge, payer),
            PoolType::OrcaWhirlpool => self.create_orca_swap_ix(edge, payer),
            // ... (rest of the code remains the same)
            PoolType::SerumV3 => self.create_serum_swap_ix(edge, payer),
            PoolType::MercurialStable => self.create_mercurial_swap_ix(edge, payer),
            PoolType::SaberStable => self.create_saber_swap_ix(edge, payer),
            PoolType::AldrinV2 => self.create_aldrin_swap_ix(edge, payer),
            PoolType::CremaFinance => self.create_crema_swap_ix(edge, payer),
            PoolType::LifinityV2 => self.create_lifinity_swap_ix(edge, payer),
        }
    }

    fn create_raydium_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        if let Some(builder) = &self.raydium_ix_builder {
            // Prefer external SDK-provided builder
            return builder(edge, payer);
        }
        let program_id = Pubkey::new_from_array([
            0x67, 0x5f, 0xc5, 0xc7, 0x6e, 0x20, 0x24, 0x7a,
            0xd7, 0xbd, 0x48, 0x26, 0x4f, 0x9a, 0x7b, 0x7a,
            0xca, 0xb1, 0xf4, 0x10, 0x32, 0x28, 0x9c, 0x3c,
            0x1a, 0x26, 0xce, 0xcd, 0xf1, 0x4c, 0xf9, 0xb7
        ]);
        
        let mut data = vec![0x09];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(from.pool_id, false),
            ],
            data,
        }
    }

    fn create_orca_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        if let Some(builder) = &self.whirlpool_ix_builder {
            // Prefer external SDK-provided builder (whirlpool-cpi layout)
            return builder(edge, payer);
        }
        let program_id = Pubkey::new_from_array([
            0x9c, 0xfb, 0x13, 0x1c, 0xae, 0x1e, 0xc6, 0xbf,
            0x22, 0x5f, 0x76, 0x4c, 0x6e, 0x3b, 0x73, 0x5c,
            0x95, 0xbe, 0x1f, 0x49, 0x0a, 0x7e, 0x8d, 0x0e,
            0x7e, 0x51, 0xd7, 0x6b, 0x6a, 0xfd, 0x7f, 0x58
        ]);
        
        let mut data = vec![0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.extend_from_slice(&[0u8; 16]);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(from.pool_id, false),
            ],
            data,
        }
    }

    fn create_serum_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        if let Some(builder) = &self.serum_ix_builder {
            // Prefer external Serum NewOrderV3/SettleFunds builder
            return builder(edge, payer);
        }
        let program_id = Pubkey::new_from_array([
            0x9a, 0xf4, 0x6f, 0xe1, 0x3e, 0x23, 0x8e, 0x2e,
            0x19, 0x71, 0xf5, 0x12, 0xab, 0x0b, 0x8c, 0x6a,
            0x02, 0x9e, 0xdd, 0x0f, 0xb4, 0x5a, 0xdb, 0x16,
            0xe1, 0x1e, 0xee, 0xc9, 0x87, 0x8a, 0x2c, 0xdb
        ]);
        
        let mut data = vec![0x00, 0x01];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_mercurial_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        let program_id = Pubkey::new_from_array([
            0x3e, 0xc0, 0xf3, 0xa9, 0x5f, 0x82, 0xe4, 0xa3,
            0xe4, 0x27, 0x32, 0xac, 0x73, 0x48, 0xf7, 0x73,
            0x8d, 0x79, 0x3c, 0x4d, 0x01, 0xf9, 0x52, 0x5c,
            0x05, 0x5d, 0xe9, 0x74, 0x1c, 0xc1, 0xca, 0xa5
        ]);
        
        let mut data = vec![0xf0, 0x1d, 0x1f];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_saber_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        let program_id = Pubkey::new_from_array([
            0x5a, 0xbe, 0xe0, 0xac, 0xef, 0xd8, 0xbc, 0xdc,
            0x0d, 0x6f, 0x86, 0x79, 0x1e, 0xb0, 0x82, 0x7b,
            0x68, 0x51, 0xe7, 0x31, 0x45, 0x08, 0x3f, 0x74,
            0xbf, 0x93, 0xc5, 0x78, 0x61, 0x1a, 0x2f, 0x81
        ]);
        
        let mut data = vec![0x01];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_aldrin_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        let program_id = Pubkey::new_from_array([
            0x2a, 0x1d, 0xea, 0x8e, 0x7f, 0xf1, 0xf8, 0x9a,
            0x7d, 0x29, 0xaf, 0x4b, 0xa8, 0x42, 0xa5, 0x08,
            0x23, 0xc5, 0x52, 0x47, 0xf5, 0xc4, 0x9c, 0xb7,
            0x7e, 0x61, 0xf7, 0x06, 0xf9, 0xa5, 0x4f, 0xfd
        ]);
        
        let mut data = vec![0xa9, 0x0c, 0x74, 0xb8];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.push(0x00);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(from.pool_id, false),
                solana_program::instruction::AccountMeta::new_readonly(from.token_a, false),
                solana_program::instruction::AccountMeta::new_readonly(from.token_b, false),
            ],
            data,
        }
    }

    fn create_crema_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        let program_id = Pubkey::new_from_array([
            0xce, 0x3e, 0x3a, 0x55, 0x97, 0xfb, 0x83, 0x43,
            0xcd, 0x43, 0xf9, 0xc5, 0x6e, 0x3f, 0xea, 0x4e,
            0xc5, 0xf1, 0xde, 0x8f, 0x3a, 0x76, 0x34, 0x1f,
            0xae, 0xa2, 0xd1, 0x4a, 0x96, 0x6a, 0x58, 0xa3
        ]);
        
        let mut data = vec![0x8b, 0xc4, 0x89, 0x48];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.extend_from_slice(&[0u8; 8]);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(from.pool_id, false),
                solana_program::instruction::AccountMeta::new_readonly(spl_token::id(), false),
            ],
            data,
        }
    }

    fn create_lifinity_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let from = self.pool_arena.read().unwrap()[edge.from_index].clone();
        let program_id = Pubkey::new_from_array([
            0x2f, 0x56, 0x36, 0x46, 0x52, 0x8f, 0xd3, 0x41,
            0xb7, 0xa5, 0x5b, 0x66, 0x8a, 0x46, 0x7a, 0x42,
            0x14, 0x46, 0x2f, 0x09, 0x7f, 0x17, 0x8e, 0x05,
            0xfb, 0x7f, 0x36, 0x6e, 0x77, 0xfb, 0x48, 0x4e
        ]);
        
        let mut data = vec![0xc1, 0x85, 0x5f, 0x82];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.push(0x01);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    pub fn optimize_for_gas(&self, mut paths: Vec<HyperPath>) -> Vec<HyperPath> {
        // Do NOT reorder edges; only recompute gas and sort by efficiency
        paths.par_iter_mut().for_each(|path| {
            path.total_gas = path.edges.iter().map(|e| e.gas_cost).sum();
        });
        paths.sort_by(|a, b| {
            let a_eff = if a.total_gas == 0 { f64::INFINITY } else { (a.total_profit as f64) / (a.total_gas as f64) };
            let b_eff = if b.total_gas == 0 { f64::INFINITY } else { (b.total_profit as f64) / (b.total_gas as f64) };
            b_eff.partial_cmp(&a_eff).unwrap_or(Ordering::Equal)
        });
        paths
    }

    // Removed unsafe edge reordering; token flow must remain intact

    pub fn calculate_optimal_split(&self, amount: u64, paths: &[HyperPath]) -> Vec<(usize, u64)> {
        if paths.is_empty() {
            return vec![];
        }
        
        let mut splits = vec![];
        let mut remaining = amount;
        
        let path_scores: Vec<_> = paths.iter().enumerate()
            .map(|(i, p)| (i, self.calculate_path_score(p)))
            .collect();
        
        let total_score: f64 = path_scores.iter().map(|(_, s)| s).sum();
        
        for (idx, score) in path_scores {
            if remaining == 0 {
                break;
            }
            
            let allocation = ((remaining as f64) * (score / total_score)) as u64;
            let final_allocation = allocation.min(remaining);
            
            if final_allocation > 0 {
                splits.push((idx, final_allocation));
                remaining = remaining.saturating_sub(final_allocation);
            }
        }
        
        if remaining > 0 && !splits.is_empty() {
            splits[0].1 += remaining;
        }
        
        splits
    }

    fn calculate_path_score(&self, path: &HyperPath) -> f64 {
        let profit_score = (path.total_profit as f64).max(0.0);
        let probability_score = path.execution_probability;
        let gas_efficiency = 1.0 / (1.0 + path.total_gas as f64 / 1_000_000.0);
        profit_score * probability_score * gas_efficiency
    }

    pub fn simulate_execution(&self, path: &HyperPath, amount: u64) -> SimulationResult {
        let mut current_amount = amount;
        let mut total_slippage = 0.0;
        let mut failed_at: Option<usize> = None;
        // Virtual reserve snapshot for CPMM pools to capture path-wise state updates
        let mut cpmm_reserves: HashMap<Pubkey, (u128, u128)> = HashMap::new();
        let arena_read = self.pool_arena.read().unwrap();

        for (idx, edge) in path.edges.iter().enumerate() {
            let from = match arena_read.get(edge.from_index) { Some(n) => n.clone(), None => { failed_at = Some(idx); break; } };
            // Compute expected output; for CPMM, update virtual reserves along the way
            let expected_output = match from.pool_type {
                PoolType::RaydiumV4 | PoolType::AldrinV2 => {
                    let entry = cpmm_reserves.entry(from.pool_id).or_insert_with(|| {
                        (from.reserves.0 as u128, from.reserves.1 as u128)
                    });
                    let (ref mut rin, ref mut rout) = entry;
                    let out_u128 = Self::apply_cpmm_swap(rin, rout, current_amount as u128, from.fee_bps as u128);
                    out_u128.and_then(|v| u64::try_from(v).ok())
                }
                _ => self.calculate_swap_output(&from, current_amount),
            };
            
            if expected_output.is_none() || expected_output.unwrap() == 0 {
                failed_at = Some(idx);
                break;
            }
            
            let simulated_output = self.simulate_with_slippage(
                expected_output.unwrap(),
                // Use the precomputed edge impact
                edge.price_impact,
            );
            
            let slippage = 1.0 - (simulated_output as f64 / expected_output.unwrap() as f64);
            self.metrics.slippage_bps.observe((slippage * 10_000.0).max(0.0));
            total_slippage += slippage;
            
            current_amount = simulated_output;
        }
        
        SimulationResult {
            success: failed_at.is_none(),
            final_amount: current_amount,
            total_slippage,
            estimated_gas: path.total_gas,
            failed_at_edge: failed_at,
        }
    }

    fn simulate_with_slippage(&self, amount: u64, base_impact: f64) -> u64 {
        let slippage_factor = 1.0 - base_impact * 1.2;
        (amount as f64 * slippage_factor.max(0.95)) as u64
    }

    pub fn get_pool_depth(&self, pool_id: &Pubkey) -> Option<u64> {
        self.pool_liquidity.get(pool_id).map(|v| *v)
    }

    pub fn prune_stale_pools(&self, current_slot: u64, max_age_slots: u64) {
        let mut graph = self.graph.write().unwrap();
        let mut adjacency = self.adjacency_matrix.write().unwrap();
        
        graph.retain(|_, nodes| {
            nodes.retain(|node| {
                current_slot.saturating_sub(node.last_update) <= max_age_slots
            });
            !nodes.is_empty()
        });
        
        adjacency.retain(|_, nodes| {
            nodes.retain(|node| {
                current_slot.saturating_sub(node.last_update) <= max_age_slots
            });
            !nodes.is_empty()
        });
        
        self.invalidate_cache();
    }

    pub fn calculate_mev_resistance(&self, path: &HyperPath) -> f64 {
        let pool_diversity = self.calculate_pool_diversity(&path.edges);
        let timing_variance = self.calculate_timing_variance(&path.edges);
        let liquidity_score = self.calculate_liquidity_score(&path.edges);
        
        (pool_diversity * 0.4 + timing_variance * 0.3 + liquidity_score * 0.3).min(1.0)
    }

    fn calculate_pool_diversity(&self, edges: &[PathEdge]) -> f64 {
        let arena = self.pool_arena.read().unwrap();
        let unique_types: HashSet<_> = edges.iter()
            .filter_map(|e| arena.get(e.from_index))
            .map(|n| std::mem::discriminant(&n.pool_type))
            .collect();
        (unique_types.len() as f64) / (edges.len() as f64).max(1.0)
    }

    fn calculate_timing_variance(&self, edges: &[PathEdge]) -> f64 {
        if edges.len() <= 1 {
            return 1.0;
        }
        
        let gas_costs: Vec<_> = edges.iter().map(|e| e.gas_cost as f64).collect();
        let mean = gas_costs.iter().sum::<f64>() / gas_costs.len() as f64;
        let variance = gas_costs.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / gas_costs.len() as f64;
        
        1.0 / (1.0 + variance.sqrt() / 10000.0)
    }

    fn calculate_liquidity_score(&self, edges: &[PathEdge]) -> f64 {
        let arena = self.pool_arena.read().unwrap();
        let total_liquidity: u64 = edges.iter()
            .filter_map(|e| arena.get(e.from_index))
            .filter_map(|n| self.pool_liquidity.get(&n.pool_id))
            .map(|l| *l)
            .sum();
        (total_liquidity as f64 / 1_000_000_000.0).min(1.0)
    }

    pub fn get_execution_stats(&self, pool_id: &Pubkey) -> Option<ExecutionStats> {
        self.execution_stats.get(pool_id).map(|s| s.clone())
    }

    pub fn parallel_find_paths(&self, tokens: Vec<Pubkey>, amount: u64) -> Vec<HyperPath> {
        tokens.par_iter()
            .flat_map(|token| self.find_optimal_paths(*token, amount, 5))
            .collect()
    }
}

#[derive(Clone, Debug)]
pub struct SimulationResult {
    pub success: bool,
    pub final_amount: u64,
    pub total_slippage: f64,
    pub estimated_gas: u64,
    pub failed_at_edge: Option<usize>,
}

// (new_with_config already implemented earlier)
