use solana_program::{
    account_info::AccountInfo,
    pubkey::Pubkey,
    clock::Clock,
    sysvar::Sysvar,
};
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::Instruction,
    signature::Keypair,
};
use std::{
    collections::{HashMap, BinaryHeap, HashSet, VecDeque},
    cmp::{Ordering, Reverse},
    sync::{Arc, RwLock},
    time::{Duration, Instant},
};
use arrayref::{array_ref, array_refs};
use borsh::{BorshDeserialize, BorshSerialize};
use dashmap::DashMap;
use rayon::prelude::*;

const MAX_DIMENSION: usize = 8;
const MAX_PATH_LENGTH: usize = 7;
const CACHE_TTL_MS: u64 = 100;
const MIN_PROFIT_BPS: u64 = 3;
const MAX_SLIPPAGE_BPS: u64 = 50;
const PRIORITY_FEE_LAMPORTS: u64 = 10000;
const MAX_COMPUTE_UNITS: u32 = 1_400_000;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct HyperNode {
    pub pool_id: Pubkey,
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub pool_type: PoolType,
    pub reserves: (u64, u64),
    pub fee_bps: u16,
    pub last_update: u64,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, BorshSerialize, BorshDeserialize)]
pub enum PoolType {
    RaydiumV4,
    OrcaWhirlpool,
    SerumV3,
    MercurialStable,
    SaberStable,
    AldrinV2,
    CremaFinance,
    LifinityV2,
}

#[derive(Clone, Debug)]
pub struct PathEdge {
    pub from: HyperNode,
    pub to: HyperNode,
    pub amount_in: u64,
    pub amount_out: u64,
    pub price_impact: f64,
    pub gas_cost: u64,
}

#[derive(Clone, Debug)]
#[derive(Serialize, Deserialize)]
pub struct HyperPath {
    pub edges: Vec<PathEdge>,
    pub total_profit: i64,
    pub execution_probability: f64,
    pub total_gas: u64,
    pub path_hash: u64,
}

impl Ord for HyperPath {
    fn cmp(&self, other: &Self) -> Ordering {
        let self_score = (self.total_profit as f64) * self.execution_probability;
        let other_score = (other.total_profit as f64) * other.execution_probability;
        self_score.partial_cmp(&other_score).unwrap_or(Ordering::Equal)
    }
}

impl PartialOrd for HyperPath {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for HyperPath {
    fn eq(&self, other: &Self) -> bool {
        self.path_hash == other.path_hash
    }
}

impl Eq for HyperPath {}

pub struct HypercubePathOptimizer {
    graph: Arc<RwLock<HashMap<Pubkey, Vec<HyperNode>>>>,
    path_cache: Arc<DashMap<u64, (HyperPath, Instant)>>,
    adjacency_matrix: Arc<RwLock<HashMap<(Pubkey, Pubkey), Vec<HyperNode>>>>,
    token_prices: Arc<DashMap<Pubkey, f64>>,
    pool_liquidity: Arc<DashMap<Pubkey, u64>>,
    execution_stats: Arc<DashMap<Pubkey, ExecutionStats>>,
}

#[derive(Clone, Debug, Default)]
struct ExecutionStats {
    success_count: u64,
    failure_count: u64,
    avg_slippage: f64,
    avg_gas_used: u64,
}

impl HypercubePathOptimizer {
    pub fn new() -> Self {
        Self {
            graph: Arc::new(RwLock::new(HashMap::new())),
            path_cache: Arc::new(DashMap::new()),
            adjacency_matrix: Arc::new(RwLock::new(HashMap::new())),
            token_prices: Arc::new(DashMap::new()),
            pool_liquidity: Arc::new(DashMap::new()),
            execution_stats: Arc::new(DashMap::new()),
        }
    }

    pub fn add_pool(&self, node: HyperNode) {
        let mut graph = self.graph.write().unwrap();
        graph.entry(node.token_a).or_insert_with(Vec::new).push(node.clone());
        graph.entry(node.token_b).or_insert_with(Vec::new).push(node.clone());
        
        let mut adj_matrix = self.adjacency_matrix.write().unwrap();
        adj_matrix.entry((node.token_a, node.token_b))
            .or_insert_with(Vec::new)
            .push(node.clone());
        adj_matrix.entry((node.token_b, node.token_a))
            .or_insert_with(Vec::new)
            .push(node);
        
        self.invalidate_cache();
    }

    pub fn find_optimal_paths(
        &self,
        start_token: Pubkey,
        target_amount: u64,
        max_paths: usize,
    ) -> Vec<HyperPath> {
        let cache_key = self.compute_cache_key(&start_token, target_amount);
        
        if let Some(cached) = self.get_cached_path(cache_key) {
            return vec![cached];
        }

        let paths = self.parallel_path_search(start_token, target_amount, max_paths);
        
        if let Some(best_path) = paths.first() {
            self.cache_path(cache_key, best_path.clone());
        }
        
        paths
    }

    fn parallel_path_search(
        &self,
        start_token: Pubkey,
        target_amount: u64,
        max_paths: usize,
    ) -> Vec<HyperPath> {
        let graph = self.graph.read().unwrap();
        let adjacency = self.adjacency_matrix.read().unwrap();
        
        let mut all_paths: Vec<HyperPath> = Vec::new();
        let mut visited = HashSet::new();
        
let initial_nodes = graph.get(&start_token).cloned().unwrap_or_else(Vec::new);
        
        let paths: Vec<_> = initial_nodes
            .par_iter()
            .flat_map(|node| {
                self.dfs_with_pruning(
                    node,
                    start_token,
                    target_amount,
                    vec![],
                    &adjacency,
                    visited.clone(),
                    0,
                )
            })
            .collect();
        
        all_paths.extend(paths);
        
        let mut heap = BinaryHeap::new();
        for path in all_paths {
            if self.validate_path(&path, target_amount) {
                heap.push(path);
            }
        }
        
        let mut result = Vec::new();
        while result.len() < max_paths && !heap.is_empty() {
            if let Some(path) = heap.pop() {
                result.push(path);
            }
        }
        
        result
    }

    fn dfs_with_pruning(
        &self,
        current: &HyperNode,
        target_token: Pubkey,
        remaining_amount: u64,
        current_path: Vec<PathEdge>,
        adjacency: &HashMap<(Pubkey, Pubkey), Vec<HyperNode>>,
        mut visited: HashSet<Pubkey>,
        depth: usize,
    ) -> Vec<HyperPath> {
        if depth >= MAX_PATH_LENGTH {
            return vec![];
        }
        
        if visited.contains(&current.pool_id) {
            return vec![];
        }
        
        visited.insert(current.pool_id);
        
        let mut paths = Vec::new();
        
        if current.token_a == target_token || current.token_b == target_token {
            if current_path.len() >= 2 {
                if let Some(path) = self.construct_path(current_path.clone(), remaining_amount) {
                    paths.push(path);
                }
            }
        }
        
        let next_token = if current.token_a == target_token {
            current.token_b
        } else {
            current.token_a
        };
        
        for neighbor_list in adjacency.values() {
            for neighbor in neighbor_list {
                if neighbor.token_a == next_token || neighbor.token_b == next_token {
                    if let Some(edge) = self.create_edge(current, neighbor, remaining_amount) {
                        if self.is_profitable_edge(&edge) {
                            let mut new_path = current_path.clone();
                            new_path.push(edge.clone());
                            
                            let sub_paths = self.dfs_with_pruning(
                                neighbor,
                                target_token,
                                edge.amount_out,
                                new_path,
                                adjacency,
                                visited.clone(),
                                depth + 1,
                            );
                            
                            paths.extend(sub_paths);
                        }
                    }
                }
            }
        }
        
        paths
    }

    fn create_edge(&self, from: &HyperNode, to: &HyperNode, amount_in: u64) -> Option<PathEdge> {
        let amount_out = self.calculate_swap_output(from, amount_in)?;
        let price_impact = self.calculate_price_impact(from, amount_in);
        let gas_cost = self.estimate_gas_cost(&from.pool_type);
        
        Some(PathEdge {
            from: from.clone(),
            to: to.clone(),
            amount_in,
            amount_out,
            price_impact,
            gas_cost,
        })
    }

    fn calculate_swap_output(&self, pool: &HyperNode, amount_in: u64) -> Option<u64> {
        let (reserve_in, reserve_out) = pool.reserves;
        
        if reserve_in == 0 || reserve_out == 0 || amount_in == 0 {
            return None;
        }
        
        let amount_in_with_fee = amount_in
            .checked_mul(10000u64.saturating_sub(pool.fee_bps as u64))?
            .checked_div(10000)?;
        
        let numerator = amount_in_with_fee.checked_mul(reserve_out)?;
        let denominator = reserve_in.checked_add(amount_in_with_fee)?;
        
        numerator.checked_div(denominator)
    }

    fn calculate_price_impact(&self, pool: &HyperNode, amount_in: u64) -> f64 {
        let (reserve_in, _) = pool.reserves;
        if reserve_in == 0 {
            return 1.0;
        }
        
        (amount_in as f64) / (reserve_in as f64)
    }

    fn estimate_gas_cost(&self, pool_type: &PoolType) -> u64 {
        match pool_type {
            PoolType::RaydiumV4 => 65000,
            PoolType::OrcaWhirlpool => 85000,
            PoolType::SerumV3 => 120000,
            PoolType::MercurialStable => 55000,
            PoolType::SaberStable => 50000,
            PoolType::AldrinV2 => 70000,
            PoolType::CremaFinance => 60000,
            PoolType::LifinityV2 => 75000,
        }
    }

    fn is_profitable_edge(&self, edge: &PathEdge) -> bool {
        if edge.price_impact > (MAX_SLIPPAGE_BPS as f64 / 10000.0) {
            return false;
        }
        
        let min_output = edge.amount_in
            .saturating_mul(10000 + MIN_PROFIT_BPS)
            .saturating_div(10000);
        
        edge.amount_out > min_output
    }

    fn construct_path(&self, edges: Vec<PathEdge>, initial_amount: u64) -> Option<HyperPath> {
        if edges.is_empty() {
            return None;
        }
        
        let total_gas: u64 = edges.iter().map(|e| e.gas_cost).sum();
        let final_amount = edges.last().map(|e| e.amount_out).ok_or_else(|| anyhow::anyhow!("construct_path failed: no edges"))?.amount_out;
        
        let total_profit = (final_amount as i64) - (initial_amount as i64) - (total_gas as i64);
        
        if total_profit <= 0 {
            return None;
        }
        
        let execution_probability = self.calculate_execution_probability(&edges);
        let path_hash = self.hash_path(&edges);
        
        Some(HyperPath {
            edges,
            total_profit,
            execution_probability,
            total_gas,
            path_hash,
        })
    }

    fn calculate_execution_probability(&self, edges: &[PathEdge]) -> f64 {
        let mut probability = 1.0;
        
        for edge in edges {
            let pool_stats = self.execution_stats
                .get(&edge.from.pool_id)
                .map(|s| s.clone())
                .\.unwrap_or_else(|| ExecutionStats::default());
            
            let success_rate = if pool_stats.success_count + pool_stats.failure_count > 0 {
                pool_stats.success_count as f64 / 
                (pool_stats.success_count + pool_stats.failure_count) as f64
            } else {
                0.95
            };
            
            let impact_penalty = 1.0 - edge.price_impact.min(0.5);
            probability *= success_rate * impact_penalty;
        }
        
        probability.max(0.0).min(1.0)
    }

    fn validate_path(&self, path: &HyperPath, min_amount: u64) -> bool {
        if path.edges.is_empty() || path.edges.len() > MAX_PATH_LENGTH {
            return false;
        }
        
        let mut current_amount = min_amount;
        let mut seen_pools = HashSet::new();
        
        for edge in &path.edges {
            if !seen_pools.insert(edge.from.pool_id) {
                return false;
            }
            
            if edge.amount_in != current_amount {
                return false;
            }
            
            if edge.amount_out == 0 || edge.price_impact > 0.5 {
                return false;
            }
            
            current_amount = edge.amount_out;
        }
        
        path.total_profit > (path.total_gas as i64) && path.execution_probability > 0.7
    }

    fn hash_path(&self, edges: &[PathEdge]) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        
        let mut hasher = DefaultHasher::new();
        for edge in edges {
            edge.from.pool_id.hash(&mut hasher);
            edge.to.pool_id.hash(&mut hasher);
        }
        hasher.finish()
    }

    fn compute_cache_key(&self, token: &Pubkey, amount: u64) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        
        let mut hasher = DefaultHasher::new();
        token.hash(&mut hasher);
        amount.hash(&mut hasher);
        hasher.finish()
    }

    fn get_cached_path(&self, key: u64) -> Option<HyperPath> {
        self.path_cache.get(&key).and_then(|(path, timestamp)| {
            if timestamp.elapsed() < Duration::from_millis(CACHE_TTL_MS) {
                Some(path.clone())
            } else {
                self.path_cache.remove(&key);
                None
            }
        })
    }

    fn cache_path(&self, key: u64, path: HyperPath) {
        self.path_cache.insert(key, (path, Instant::now()));
        
        if self.path_cache.len() > 10000 {
            self.cleanup_expired_cache();
        }
    }

    fn cleanup_expired_cache(&self) {
        let now = Instant::now();
        self.path_cache.retain(|_, (_, timestamp)| {
            now.duration_since(*timestamp) < Duration::from_millis(CACHE_TTL_MS * 2)
        });
    }

    fn invalidate_cache(&self) {
        self.path_cache.clear();
    }

    pub fn update_pool_state(&self, pool_id: Pubkey, reserves: (u64, u64), slot: u64) {
        let mut graph = self.graph.write().unwrap();
        let mut adjacency = self.adjacency_matrix.write().unwrap();
        
        for nodes in graph.values_mut() {
            for node in nodes.iter_mut() {
                if node.pool_id == pool_id {
                    node.reserves = reserves;
                    node.last_update = slot;
                }
            }
        }
        
        for nodes in adjacency.values_mut() {
            for node in nodes.iter_mut() {
                if node.pool_id == pool_id {
                    node.reserves = reserves;
                    node.last_update = slot;
                }
            }
        }
        
        self.pool_liquidity.insert(pool_id, reserves.0 + reserves.1);
        self.invalidate_cache();
    }

    pub fn update_token_price(&self, token: Pubkey, price_usd: f64) {
        self.token_prices.insert(token, price_usd);
    }

    pub fn update_execution_stats(
        &self,
        pool_id: Pubkey,
        success: bool,
        slippage: f64,
        gas_used: u64,
    ) {
        self.execution_stats
            .entry(pool_id)
            .and_modify(|stats| {
                if success {
                    stats.success_count += 1;
                } else {
                    stats.failure_count += 1;
                }
                
                let total_executions = stats.success_count + stats.failure_count;
                stats.avg_slippage = (stats.avg_slippage * (total_executions - 1) as f64 + slippage) 
                    / total_executions as f64;
                stats.avg_gas_used = (stats.avg_gas_used * (total_executions - 1) + gas_used) 
                    / total_executions;
            })
            .or_insert(ExecutionStats {
                success_count: if success { 1 } else { 0 },
                failure_count: if success { 0 } else { 1 },
                avg_slippage: slippage,
                avg_gas_used: gas_used,
            });
    }

    pub fn generate_instructions(&self, path: &HyperPath, payer: &Pubkey) -> Vec<Instruction> {
        let mut instructions = vec![];
        
        instructions.push(ComputeBudgetInstruction::set_compute_unit_limit(MAX_COMPUTE_UNITS));
        instructions.push(ComputeBudgetInstruction::set_compute_unit_price(PRIORITY_FEE_LAMPORTS));
        
        for edge in &path.edges {
            let swap_ix = self.create_swap_instruction(&edge, payer);
            instructions.push(swap_ix);
        }
        
        instructions
    }

    fn create_swap_instruction(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        match edge.from.pool_type {
            PoolType::RaydiumV4 => self.create_raydium_swap_ix(edge, payer),
            PoolType::OrcaWhirlpool => self.create_orca_swap_ix(edge, payer),
            PoolType::SerumV3 => self.create_serum_swap_ix(edge, payer),
            PoolType::MercurialStable => self.create_mercurial_swap_ix(edge, payer),
            PoolType::SaberStable => self.create_saber_swap_ix(edge, payer),
            PoolType::AldrinV2 => self.create_aldrin_swap_ix(edge, payer),
            PoolType::CremaFinance => self.create_crema_swap_ix(edge, payer),
            PoolType::LifinityV2 => self.create_lifinity_swap_ix(edge, payer),
        }
    }

    fn create_raydium_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x67, 0x5f, 0xc5, 0xc7, 0x6e, 0x20, 0x24, 0x7a,
            0xd7, 0xbd, 0x48, 0x26, 0x4f, 0x9a, 0x7b, 0x7a,
            0xca, 0xb1, 0xf4, 0x10, 0x32, 0x28, 0x9c, 0x3c,
            0x1a, 0x26, 0xce, 0xcd, 0xf1, 0x4c, 0xf9, 0xb7
        ]);
        
        let mut data = vec![0x09];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_orca_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x9c, 0xfb, 0x13, 0x1c, 0xae, 0x1e, 0xc6, 0xbf,
            0x22, 0x5f, 0x76, 0x4c, 0x6e, 0x3b, 0x73, 0x5c,
            0x95, 0xbe, 0x1f, 0x49, 0x0a, 0x7e, 0x8d, 0x0e,
            0x7e, 0x51, 0xd7, 0x6b, 0x6a, 0xfd, 0x7f, 0x58
        ]);
        
        let mut data = vec![0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.extend_from_slice(&[0u8; 16]);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_serum_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x9a, 0xf4, 0x6f, 0xe1, 0x3e, 0x23, 0x8e, 0x2e,
            0x19, 0x71, 0xf5, 0x12, 0xab, 0x0b, 0x8c, 0x6a,
            0x02, 0x9e, 0xdd, 0x0f, 0xb4, 0x5a, 0xdb, 0x16,
            0xe1, 0x1e, 0xee, 0xc9, 0x87, 0x8a, 0x2c, 0xdb
        ]);
        
        let mut data = vec![0x00, 0x01];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_mercurial_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x3e, 0xc0, 0xf3, 0xa9, 0x5f, 0x82, 0xe4, 0xa3,
            0xe4, 0x27, 0x32, 0xac, 0x73, 0x48, 0xf7, 0x73,
            0x8d, 0x79, 0x3c, 0x4d, 0x01, 0xf9, 0x52, 0x5c,
            0x05, 0x5d, 0xe9, 0x74, 0x1c, 0xc1, 0xca, 0xa5
        ]);
        
        let mut data = vec![0xf0, 0x1d, 0x1f];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_saber_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x5a, 0xbe, 0xe0, 0xac, 0xef, 0xd8, 0xbc, 0xdc,
            0x0d, 0x6f, 0x86, 0x79, 0x1e, 0xb0, 0x82, 0x7b,
            0x68, 0x51, 0xe7, 0x31, 0x45, 0x08, 0x3f, 0x74,
            0xbf, 0x93, 0xc5, 0x78, 0x61, 0x1a, 0x2f, 0x81
        ]);
        
        let mut data = vec![0x01];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    fn create_aldrin_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x2a, 0x1d, 0xea, 0x8e, 0x7f, 0xf1, 0xf8, 0x9a,
            0x7d, 0x29, 0xaf, 0x4b, 0xa8, 0x42, 0xa5, 0x08,
            0x23, 0xc5, 0x52, 0x47, 0xf5, 0xc4, 0x9c, 0xb7,
            0x7e, 0x61, 0xf7, 0x06, 0xf9, 0xa5, 0x4f, 0xfd
        ]);
        
        let mut data = vec![0xa9, 0x0c, 0x74, 0xb8];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.push(0x00);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
                solana_program::instruction::AccountMeta::new_readonly(edge.from.token_a, false),
                solana_program::instruction::AccountMeta::new_readonly(edge.from.token_b, false),
            ],
            data,
        }
    }

    fn create_crema_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0xce, 0x3e, 0x3a, 0x55, 0x97, 0xfb, 0x83, 0x43,
            0xcd, 0x43, 0xf9, 0xc5, 0x6e, 0x3f, 0xea, 0x4e,
            0xc5, 0xf1, 0xde, 0x8f, 0x3a, 0x76, 0x34, 0x1f,
            0xae, 0xa2, 0xd1, 0x4a, 0x96, 0x6a, 0x58, 0xa3
        ]);
        
        let mut data = vec![0x8b, 0xc4, 0x89, 0x48];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.extend_from_slice(&[0u8; 8]);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
                solana_program::instruction::AccountMeta::new_readonly(spl_token::id(), false),
            ],
            data,
        }
    }

    fn create_lifinity_swap_ix(&self, edge: &PathEdge, payer: &Pubkey) -> Instruction {
        let program_id = Pubkey::new_from_array([
            0x2f, 0x56, 0x36, 0x46, 0x52, 0x8f, 0xd3, 0x41,
            0xb7, 0xa5, 0x5b, 0x66, 0x8a, 0x46, 0x7a, 0x42,
            0x14, 0x46, 0x2f, 0x09, 0x7f, 0x17, 0x8e, 0x05,
            0xfb, 0x7f, 0x36, 0x6e, 0x77, 0xfb, 0x48, 0x4e
        ]);
        
        let mut data = vec![0xc1, 0x85, 0x5f, 0x82];
        data.extend_from_slice(&edge.amount_in.to_le_bytes());
        data.extend_from_slice(&edge.amount_out.to_le_bytes());
        data.push(0x01);
        
        Instruction {
            program_id,
            accounts: vec![
                solana_program::instruction::AccountMeta::new(*payer, true),
                solana_program::instruction::AccountMeta::new(edge.from.pool_id, false),
            ],
            data,
        }
    }

    pub fn optimize_for_gas(&self, paths: Vec<HyperPath>) -> Vec<HyperPath> {
        let mut optimized_paths = paths;
        
        optimized_paths.par_iter_mut().for_each(|path| {
            let gas_optimized_edges = self.reorder_edges_for_gas(&path.edges);
            path.edges = gas_optimized_edges;
            path.total_gas = path.edges.iter().map(|e| e.gas_cost).sum();
        });
        
        optimized_paths.sort_by(|a, b| {
            let a_efficiency = (a.total_profit as f64) / (a.total_gas as f64);
            let b_efficiency = (b.total_profit as f64) / (b.total_gas as f64);
            b_efficiency.partial_cmp(&a_efficiency).unwrap_or(Ordering::Equal)
        });
        
        optimized_paths
    }

    fn reorder_edges_for_gas(&self, edges: &[PathEdge]) -> Vec<PathEdge> {
        if edges.len() <= 2 {
            return edges.to_vec();
        }
        
        let mut optimized = edges.to_vec();
        let mut improved = true;
        
        while improved {
            improved = false;
            for i in 0..optimized.len() - 1 {
                let current_gas = optimized[i].gas_cost + optimized[i + 1].gas_cost;
                
                if self.can_swap_edges(&optimized[i], &optimized[i + 1]) {
                    optimized.swap(i, i + 1);
                    let new_gas = optimized[i].gas_cost + optimized[i + 1].gas_cost;
                    
                    if new_gas >= current_gas {
                        optimized.swap(i, i + 1);
                    } else {
                        improved = true;
                    }
                }
            }
        }
        
        optimized
    }

    fn can_swap_edges(&self, edge1: &PathEdge, edge2: &PathEdge) -> bool {
        edge1.to.token_a != edge2.from.token_a && 
        edge1.to.token_b != edge2.from.token_b
    }

    pub fn calculate_optimal_split(&self, amount: u64, paths: &[HyperPath]) -> Vec<(usize, u64)> {
        if paths.is_empty() {
            return vec![];
        }
        
        let mut splits = vec![];
        let mut remaining = amount;
        
        let path_scores: Vec<_> = paths.iter().enumerate()
            .map(|(i, p)| (i, self.calculate_path_score(p)))
            .collect();
        
        let total_score: f64 = path_scores.iter().map(|(_, s)| s).sum();
        
        for (idx, score) in path_scores {
            if remaining == 0 {
                break;
            }
            
            let allocation = ((remaining as f64) * (score / total_score)) as u64;
            let final_allocation = allocation.min(remaining);
            
            if final_allocation > 0 {
                splits.push((idx, final_allocation));
                remaining = remaining.saturating_sub(final_allocation);
            }
        }
        
        if remaining > 0 && !splits.is_empty() {
            splits[0].1 += remaining;
        }
        
        splits
    }

    fn calculate_path_score(&self, path: &HyperPath) -> f64 {
        let profit_score = (path.total_profit as f64).max(0.0);
        let probability_score = path.execution_probability;
        let gas_efficiency = 1.0 / (1.0 + path.total_gas as f64 / 1_000_000.0);
        
        profit_score * probability_score * gas_efficiency
    }

    pub fn simulate_execution(&self, path: &HyperPath, amount: u64) -> SimulationResult {
        let mut current_amount = amount;
        let mut total_slippage = 0.0;
        let mut failed_at: Option<usize> = None;
        
        for (idx, edge) in path.edges.iter().enumerate() {
            let expected_output = self.calculate_swap_output(&edge.from, current_amount);
            
            if expected_output.is_none() || expected_output.unwrap() == 0 {
                failed_at = Some(idx);
                break;
            }
            
            let simulated_output = self.simulate_with_slippage(
                expected_output.unwrap(),
                edge.price_impact,
            );
            
            let slippage = 1.0 - (simulated_output as f64 / expected_output.unwrap() as f64);
            total_slippage += slippage;
            
            current_amount = simulated_output;
        }
        
        SimulationResult {
            success: failed_at.is_none(),
            final_amount: current_amount,
            total_slippage,
            estimated_gas: path.total_gas,
            failed_at_edge: failed_at,
        }
    }

    fn simulate_with_slippage(&self, amount: u64, base_impact: f64) -> u64 {
        let slippage_factor = 1.0 - base_impact * 1.2;
        (amount as f64 * slippage_factor.max(0.95)) as u64
    }

    pub fn get_pool_depth(&self, pool_id: &Pubkey) -> Option<u64> {
        self.pool_liquidity.get(pool_id).map(|v| *v)
    }

    pub fn prune_stale_pools(&self, current_slot: u64, max_age_slots: u64) {
        let mut graph = self.graph.write().unwrap();
        let mut adjacency = self.adjacency_matrix.write().unwrap();
        
        graph.retain(|_, nodes| {
            nodes.retain(|node| {
                current_slot.saturating_sub(node.last_update) <= max_age_slots
            });
            !nodes.is_empty()
        });
        
        adjacency.retain(|_, nodes| {
            nodes.retain(|node| {
                current_slot.saturating_sub(node.last_update) <= max_age_slots
            });
            !nodes.is_empty()
        });
        
        self.invalidate_cache();
    }

    pub fn calculate_mev_resistance(&self, path: &HyperPath) -> f64 {
        let pool_diversity = self.calculate_pool_diversity(&path.edges);
        let timing_variance = self.calculate_timing_variance(&path.edges);
        let liquidity_score = self.calculate_liquidity_score(&path.edges);
        
        (pool_diversity * 0.4 + timing_variance * 0.3 + liquidity_score * 0.3).min(1.0)
    }

    fn calculate_pool_diversity(&self, edges: &[PathEdge]) -> f64 {
        let unique_types: HashSet<_> = edges.iter()
            .map(|e| std::mem::discriminant(&e.from.pool_type))
            .collect();
        
        (unique_types.len() as f64) / (edges.len() as f64).max(1.0)
    }

    fn calculate_timing_variance(&self, edges: &[PathEdge]) -> f64 {
        if edges.len() <= 1 {
            return 1.0;
        }
        
        let gas_costs: Vec<_> = edges.iter().map(|e| e.gas_cost as f64).collect();
        let mean = gas_costs.iter().sum::<f64>() / gas_costs.len() as f64;
        let variance = gas_costs.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / gas_costs.len() as f64;
        
        1.0 / (1.0 + variance.sqrt() / 10000.0)
    }

    fn calculate_liquidity_score(&self, edges: &[PathEdge]) -> f64 {
        let total_liquidity: u64 = edges.iter()
            .filter_map(|e| self.pool_liquidity.get(&e.from.pool_id))
            .map(|l| *l)
            .sum();
        
        (total_liquidity as f64 / 1_000_000_000.0).min(1.0)
    }

    pub fn get_execution_stats(&self, pool_id: &Pubkey) -> Option<ExecutionStats> {
        self.execution_stats.get(pool_id).map(|s| s.clone())
    }

    pub fn parallel_find_paths(&self, tokens: Vec<Pubkey>, amount: u64) -> Vec<HyperPath> {
        tokens.par_iter()
            .flat_map(|token| self.find_optimal_paths(*token, amount, 5))
            .collect()
    }
}

#[derive(Clone, Debug)]
pub struct SimulationResult {
    pub success: bool,
    pub final_amount: u64,
    pub total_slippage: f64,
    pub estimated_gas: u64,
    pub failed_at_edge: Option<usize>,
}

impl HypercubePathOptimizer {
    pub fn new_with_config(max_paths_cache: usize, parallel_threads: usize) -> Self {
        rayon::ThreadPoolBuilder::new()
            .num_threads(parallel_threads)
            .build_global()
            .let _ = build_global();
        
        Self::new()
    }
}
