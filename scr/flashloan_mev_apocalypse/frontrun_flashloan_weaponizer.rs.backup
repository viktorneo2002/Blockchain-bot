use solana_transaction_status::option_serializer::OptionSerializer;
use solana_account_decoder::UiAccountEncoding;
use anyhow::{Result, anyhow};
use anchor_lang::prelude::*;
use solana_client::{
    nonblocking::rpc_client::RpcClient,
    rpc_config::{RpcTransactionConfig, RpcSendTransactionConfig},
    rpc_response::RpcLogsResponse,
};
use solana_sdk::{
    commitment_config::{CommitmentConfig, CommitmentLevel},
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signature},
    signer::Signer,
    transaction::{VersionedTransaction},
    message::{v0, VersionedMessage},
};
use solana_transaction_status::{
    EncodedConfirmedTransactionWithStatusMeta, UiTransactionEncoding,
};
use std::{
    collections::{HashMap, VecDeque},
    str::FromStr,
    sync::Arc,
    time::{Duration, Instant},
};
use tokio::{
    sync::{Mutex, RwLock, mpsc},
    time::sleep,
};
use borsh::{BorshDeserialize, BorshSerialize};
use dashmap::DashMap;
use futures_util::{StreamExt, stream::SplitSink};
use solana_client::nonblocking::pubsub_client::PubsubClient;
use spl_associated_token_account::get_associated_token_address;

// Production Mainnet Program IDs
const SOLEND_PROGRAM_ID: &str = "So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo";
const RAYDIUM_V4_PROGRAM_ID: &str = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8";
const ORCA_WHIRLPOOL_PROGRAM_ID: &str = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
const JUPITER_AGGREGATOR_V6: &str = "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4";
const SERUM_DEX_V3: &str = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin";

const MAX_COMPUTE_UNITS: u32 = 1_400_000;
const BASE_PRIORITY_FEE: u64 = 25_000;
const FLASH_LOAN_FEE_BPS: u16 = 9; // 0.09%
const MIN_PROFIT_THRESHOLD: u64 = 10_000_000; // 0.01 SOL

#[derive(Clone)]
pub struct FrontrunFlashLoanWeaponizer {
    rpc: Arc<RpcClient>,
    ws_client: Arc<Mutex<PubsubClient>>,
    keypair: Arc<Keypair>,
    opportunity_tracker: Arc<DashMap<String, ArbitrageOpportunity>>,
    execution_queue: Arc<RwLock<VecDeque<ExecutionTask>>>,
    pool_cache: Arc<DashMap<Pubkey, PoolState>>,
    tx_sender: mpsc::Sender<ExecutionTask>,
    tx_receiver: Arc<Mutex<mpsc::Receiver<ExecutionTask>>>,
}

#[derive(Clone, Debug)]
struct ArbitrageOpportunity {
    id: String,
    target_signature: String,
    profit_estimate: u64,
    token_mint: Pubkey,
    path: Vec<SwapLeg>,
    flash_amount: u64,
    deadline_slot: u64,
    priority_fee: u64,
    confidence_score: f64,
}

#[derive(Clone, Debug)]
struct SwapLeg {
    program_id: Pubkey,
    pool_address: Pubkey,
    input_mint: Pubkey,
    output_mint: Pubkey,
    direction: SwapDirection,
    reserves_in: u64,
    reserves_out: u64,
    fee: u16,
}

#[derive(Clone, Debug)]
enum SwapDirection {
    AToB,
    BToA,
}

#[derive(Clone, Debug)]
struct PoolState {
    program_id: Pubkey,
    pool_address: Pubkey,
    token_a: Pubkey,
    token_b: Pubkey,
    reserve_a: u64,
    reserve_b: u64,
    fee_numerator: u64,
    fee_denominator: u64,
    last_update_slot: u64,
}

#[derive(Clone)]
struct ExecutionTask {
    opportunity: ArbitrageOpportunity,
    attempt: u8,
    created_at: Instant,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct SolendFlashLoanBegin {
    instruction: u8,
    amount: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct SolendFlashLoanEnd {
    instruction: u8,
}

impl FrontrunFlashLoanWeaponizer {
    pub async fn new(
        rpc_url: &str,
        ws_url: &str,
        keypair: Keypair,
    ) -> std::result::Result<Self, anyhow::Error> {
        let rpc = Arc::new(RpcClient::new_with_commitment(
            rpc_url.to_string(),
            CommitmentConfig {
                commitment: CommitmentLevel::Processed,
            },
        ));
        
        let ws_client = Arc::new(Mutex::new(PubsubClient::new(ws_url).await?));
        let (tx_sender, tx_receiver) = mpsc::channel::<ExecutionTask>(1000);
        
        Ok(Self {
            rpc,
            ws_client,
            keypair: Arc::new(keypair),
            opportunity_tracker: Arc::new(DashMap::new()),
            execution_queue: Arc::new(RwLock::new(VecDeque::new())),
            pool_cache: Arc::new(DashMap::new()),
            tx_sender,
            tx_receiver: Arc::new(Mutex::new(tx_receiver)),
        })
    }

    pub async fn run(&self) -> Result<()> {
        let mut handles = vec![];
        
        // Mempool monitoring
        let monitor = self.clone();
        handles.push(tokio::spawn(async move {
            monitor.monitor_transactions().await
        }));
        
        // Pool state updater
        let updater = self.clone();
        handles.push(tokio::spawn(async move {
            updater.update_pool_states().await
        }));
        
        // Opportunity analyzer
        let analyzer = self.clone();
        handles.push(tokio::spawn(async move {
            analyzer.analyze_opportunities().await
        }));
        
        // Executor workers (3 parallel)
        for i in 0..3 {
            let executor = self.clone();
            handles.push(tokio::spawn(async move {
                executor.execute_opportunities().await
            }));
        }
        
        futures::future::try_join_all(handles).await?;
        Ok(())
    }

    }

    async fn process_log(&self, log: RpcLogsResponse) -> Result<()> {
        let slot = 0; // TODO: Get slot from elsewhere
        
        tokio::spawn({
            let self_clone = self.clone();
            let sig = log.signature.clone();
            async move {
                sleep(Duration::from_millis(50)).await;
                if let Ok(tx) = self_clone.fetch_transaction(&sig).await {
                    let _ = self_clone.analyze_transaction(tx, slot).await;
                }
            }
        });
        
        Ok(())
    }

    async fn fetch_transaction(
        &self,
        signature: &str,
    ) -> std::result::Result<EncodedConfirmedTransactionWithStatusMeta, anyhow::Error> {
        let config = RpcTransactionConfig {
            encoding: Some(UiTransactionEncoding::Base64),
            commitment: Some(CommitmentConfig::processed()),
            max_supported_transaction_version: Some(0),
        };
        
        let sig = Signature::from_str(signature)?;
        self.rpc.get_transaction_with_config(&sig, config).await
            .map_err(|e| e.into())
    }

    async fn analyze_transaction(
        &self,
        tx: EncodedConfirmedTransactionWithStatusMeta,
        slot: u64,
    ) -> Result<()> {
        let meta = tx.transaction.meta.as_ref().ok_or(anyhow::anyhow!("No transaction meta"))?;
        if meta.err.is_some() {
            return Ok(());
        }
        
        let pre_balances = &meta.pre_token_balances;
        let post_balances = &meta.post_token_balances;
        
        let mut token_deltas: HashMap<Pubkey, i128> = HashMap::new();
        

        // Parse token balance changes
        if let (OptionSerializer::Some(pre_list), OptionSerializer::Some(post_list)) = (pre_balances, post_balances) {
            for (pre, post) in pre_list.iter().zip(post_list.iter()) {
                if pre.mint == post.mint {
                    let pre_amount = pre.ui_token_amount.amount.parse::<i128>().unwrap_or(0);
                    let post_amount = post.ui_token_amount.amount.parse::<i128>().unwrap_or(0);
                    let delta = post_amount - pre_amount;
                    if delta != 0 {
                        let mint = Pubkey::from_str(&pre.mint).unwrap_or_default();
                        token_deltas.insert(mint, delta);
                    }
                }
            }
        }

        // Detect arbitrage opportunity
        if let Some(opportunity) = self.detect_arbitrage(&token_deltas, slot).await? {
            self.opportunity_tracker.insert(opportunity.id.clone(), opportunity.clone());
            self.tx_sender.send(ExecutionTask {
                opportunity,
                attempt: 0,
                created_at: Instant::now(),
            }).await?;
        }
        Ok(())
    }
            

    async fn find_arbitrage_paths(
        &self,
        token_mint: &Pubkey,
    ) -> std::result::Result<Vec<Vec<SwapLeg>>, anyhow::Error> {
        let mut paths = Vec::new();
        let _wsol = spl_token::native_mint::id();
        
        // Get all pools involving this token
        let relevant_pools: Vec<_> = self.pool_cache
            .iter()
            .filter(|entry| {
                let pool = entry.value();
                pool.token_a == *token_mint || pool.token_b == *token_mint
            })
            .map(|entry| entry.value().clone())
            .collect();
        
        // Build 2-hop and 3-hop paths
        for pool1 in &relevant_pools {
            let intermediate = if pool1.token_a == *token_mint {
                pool1.token_b
            } else {
                pool1.token_a
            };
            
            for pool2 in &relevant_pools {
                if pool2.pool_address == pool1.pool_address {
                    continue;
                }
                
                let connects = (pool2.token_a == intermediate || pool2.token_b == intermediate)
                    && (pool2.token_a == *token_mint || pool2.token_b == *token_mint);
                
                if connects {
                    let path = vec![
                        self.create_swap_leg(pool1, *token_mint, intermediate)?,
                        self.create_swap_leg(pool2, intermediate, *token_mint)?,
                    ];
                    paths.push(path);
                }
            }
        }
        
        Ok(paths)
    }

    fn create_swap_leg(
        &self,
        pool: &PoolState,
        input_mint: Pubkey,
        output_mint: Pubkey,
    ) -> std::result::Result<SwapLeg, anyhow::Error> {
        let direction = if pool.token_a == input_mint {
            SwapDirection::AToB
        } else {
            SwapDirection::BToA
        };
        
        let (reserves_in, reserves_out) = match direction {
            SwapDirection::AToB => (pool.reserve_a, pool.reserve_b),
            SwapDirection::BToA => (pool.reserve_b, pool.reserve_a),
        };
        
        Ok(SwapLeg {
            program_id: pool.program_id,
            pool_address: pool.pool_address,
            input_mint,
            output_mint,
            direction,
            reserves_in,
            reserves_out,
            fee: (pool.fee_numerator * 10000 / pool.fee_denominator) as u16,
        })
    }

    fn calculate_optimal_arbitrage(
        &self,
        path: &[SwapLeg],
    ) -> std::result::Result<(u64, u64), anyhow::Error> {
        let mut best_profit = 0u64;
        let mut best_amount = 0u64;
        
        let max_input = path[0].reserves_in / 10;
        let step_size = max_input / 100;
        
        for i in 1..=100 {
            let test_amount = step_size * i;
            let mut current_amount = test_amount;
            
            for leg in path {
                current_amount = self.calculate_swap_output(
                    current_amount,
                    leg.reserves_in,
                    leg.reserves_out,
                    leg.fee,
                )?;
            }
            
            let flash_fee = test_amount * FLASH_LOAN_FEE_BPS as u64 / 10000;
            let profit = current_amount.saturating_sub(test_amount + flash_fee);
            
            if profit > best_profit {
                best_profit = profit;
                best_amount = test_amount;
            }
        }
        
        Ok((best_profit, best_amount))
    }

    fn calculate_swap_output(
        &self,
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
        fee_bps: u16,
    ) -> std::result::Result<u64, anyhow::Error> {
        let amount_in_with_fee = (amount_in as u128) * (10000 - fee_bps as u128) / 10000;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) + amount_in_with_fee;
        
        Ok((numerator / denominator) as u64)
    }

    fn calculate_dynamic_priority_fee(&self, expected_profit: u64) -> u64 {
        let base_fee = BASE_PRIORITY_FEE;
        let profit_percentage = expected_profit / 100;
        let dynamic_fee = base_fee + profit_percentage;
        
        dynamic_fee.min(expected_profit / 2)
    }

    fn calculate_confidence_score(&self, profit: u64, amount: u64) -> f64 {
        let profit_ratio = profit as f64 / amount as f64;
        let base_score = profit_ratio.min(0.1) * 10.0;
        
        base_score * 0.9
    }

    async fn update_pool_states(&self) -> Result<()> {
        Ok(())
    }


    async fn update_raydium_pools(
        &self,
        program_id: Pubkey,
    ) -> Result<()> {
        let accounts = self.rpc.get_program_accounts_with_config(
            &program_id,
            solana_client::rpc_config::RpcProgramAccountsConfig {
                filters: Some(vec![solana_client::rpc_filter::RpcFilterType::DataSize(752)]),
                account_config: solana_client::rpc_config::RpcAccountInfoConfig {
                    encoding: Some(UiAccountEncoding::Base64),
                    commitment: Some(CommitmentConfig::processed()),
                    ..Default::default()
                },
                ..Default::default()
            },
        ).await?;
        
        for (pubkey, account) in accounts.iter().take(50) {
            if account.data.len() >= 752 {
                let pool_state = self.parse_raydium_pool(&account.data)?;
                self.pool_cache.insert(*pubkey, pool_state);
            }
        }
        
        Ok(())
    }

    async fn update_orca_pools(
        &self,
        program_id: Pubkey,
    ) -> Result<()> {
        let accounts = self.rpc.get_program_accounts_with_config(
            &program_id,
            solana_client::rpc_config::RpcProgramAccountsConfig {
                filters: Some(vec![solana_client::rpc_filter::RpcFilterType::DataSize(653)]),
                account_config: solana_client::rpc_config::RpcAccountInfoConfig {
                    encoding: Some(UiAccountEncoding::Base64),
                    commitment: Some(CommitmentConfig::processed()),
                    ..Default::default()
                },
                ..Default::default()
            },
        ).await?;
        
        for (pubkey, account) in accounts.iter().take(50) {
            if account.data.len() >= 653 {
                let pool_state = self.parse_orca_pool(&account.data)?;
                self.pool_cache.insert(*pubkey, pool_state);
            }
        }
        
        Ok(())
    }

    fn parse_raydium_pool(&self, data: &[u8]) -> std::result::Result<PoolState, anyhow::Error> {
        let token_a = Pubkey::try_from(&data[97..129]).map_err(|e| anyhow!("Invalid pubkey: {:?}", e))?;
        let token_b = Pubkey::try_from(&data[129..161]).map_err(|e| anyhow!("Invalid pubkey: {:?}", e))?;
        let reserve_a = u64::from_le_bytes(data[161..169].try_into()?);
        let reserve_b = u64::from_le_bytes(data[169..177].try_into()?);
        
        Ok(PoolState {
            program_id: Pubkey::from_str(RAYDIUM_V4_PROGRAM_ID)?,
            pool_address: Pubkey::try_from(&data[0..32]).map_err(|e| anyhow!("Invalid pubkey: {:?}", e))?,
            token_a,
            token_b,
            reserve_a,
            reserve_b,
            fee_numerator: 25,
            fee_denominator: 10000,
            last_update_slot: 0,
        })
    }

    fn parse_orca_pool(&self, data: &[u8]) -> std::result::Result<PoolState, anyhow::Error> {
        let token_a = Pubkey::try_from(&data[101..133]).map_err(|e| anyhow!("Invalid pubkey: {:?}", e))?;
        let token_b = Pubkey::try_from(&data[181..213]).map_err(|e| anyhow!("Invalid pubkey: {:?}", e))?;
        let sqrt_price = u128::from_le_bytes(data[65..81].try_into()?);
        let liquidity = u128::from_le_bytes(data[81..97].try_into()?);
        
        let _price = (sqrt_price * sqrt_price) >> 64;
        let reserve_a = ((liquidity << 64) / sqrt_price) as u64;
        let reserve_b = ((liquidity * sqrt_price) >> 64) as u64;
        
        Ok(PoolState {
            program_id: Pubkey::from_str(ORCA_WHIRLPOOL_PROGRAM_ID)?,
            pool_address: Pubkey::try_from(&data[0..32]).map_err(|e| anyhow!("Invalid pubkey: {:?}", e))?,
            token_a,
            token_b,
            reserve_a,
            reserve_b,
            fee_numerator: 30,
            fee_denominator: 10000,
            last_update_slot: 0,
        })
    }

    async fn analyze_opportunities(&self) -> Result<()> {
        loop {
            let current_slot = self.rpc.get_slot().await?;
            
            let expired: Vec<_> = self.opportunity_tracker
                .iter()
                .filter(|entry| entry.value().deadline_slot < current_slot)
                .map(|entry| entry.key().clone())
                .collect();
            
            for key in expired {
                self.opportunity_tracker.remove(&key);
            }
            
            sleep(Duration::from_millis(100)).await;
        }
    }

    async fn execute_opportunities(&self) -> Result<()> {
        let mut receiver = self.tx_receiver.lock().await;
        
        while let Some(task) = receiver.recv().await {
            if task.created_at.elapsed() > Duration::from_secs(30) {
                continue;
            }
            
            match self.execute_arbitrage(&task.opportunity).await {
                Ok(signature) => {
                    println!("Executed arbitrage: {} profit: {} SOL", 
                        signature, 
                        task.opportunity.profit_estimate as f64 / 1e9
                    );
                    self.opportunity_tracker.remove(&task.opportunity.id);
                }
                Err(e) => {
                    if task.attempt < 3 {
                        let mut retry_task = task.clone();
                        retry_task.attempt += 1;
                        let _ = self.tx_sender.send(retry_task).await;
                    }
                }
            }
        }
        
        Ok(())
    }

    async fn execute_arbitrage(
        &self,
        opportunity: &ArbitrageOpportunity,
    ) -> std::result::Result<Signature, anyhow::Error> {
        let mut instructions = vec![];
        
        instructions.push(ComputeBudgetInstruction::set_compute_unit_limit(MAX_COMPUTE_UNITS));
        instructions.push(ComputeBudgetInstruction::set_compute_unit_price(opportunity.priority_fee));
        
        let flash_loan_ix = self.build_flash_loan_begin(
            opportunity.token_mint,
            opportunity.flash_amount,
        )?;
        instructions.push(flash_loan_ix);
        
        for leg in &opportunity.path {
            let swap_ix = self.build_swap_instruction(leg, opportunity.flash_amount)?;
            instructions.push(swap_ix);
        }
        
        let repay_ix = self.build_flash_loan_end()?;
        instructions.push(repay_ix);
        
        let recent_blockhash = self.rpc.get_latest_blockhash().await?;
        
        let message = v0::Message::try_compile(
            &self.keypair.pubkey(),
            &instructions,
            &[],
            recent_blockhash,
        )?;
        
        let versioned_message = VersionedMessage::V0(message);
        let versioned_tx = VersionedTransaction::try_new(
            versioned_message,
            &[&*self.keypair],
        )?;
        
        let config = RpcSendTransactionConfig {
            skip_preflight: true,
            preflight_commitment: Some(CommitmentLevel::Processed),
            max_retries: Some(0),
            ..Default::default()
        };
        
        let signature = self.rpc.send_transaction_with_config(&versioned_tx, config).await?;
        
        let start = Instant::now();
        loop {
            if start.elapsed() > Duration::from_secs(30) {
                return Err(anyhow::anyhow!("Transaction timeout"));
            }
            
            match self.rpc.get_signature_status(&signature).await.map_err(|_| anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::InvalidProgramId))? {
                Some(Ok(())) => return Ok(signature),
                Some(Err(e)) => return Err(anyhow::anyhow!("Transaction failed: {}", e)),
                None => sleep(Duration::from_millis(500)).await,
            }
        }
    }

    fn build_flash_loan_begin(
        &self,
        token_mint: Pubkey,
        amount: u64,
    ) -> std::result::Result<Instruction, anyhow::Error> {
        let solend_program = Pubkey::from_str(SOLEND_PROGRAM_ID)?;
        let token_account = get_associated_token_address(&self.keypair.pubkey(), &token_mint);
        
        let data = SolendFlashLoanBegin {
            instruction: 14,
            amount,
        };
        
        Ok(Instruction {
            program_id: solend_program,
            accounts: vec![
                AccountMeta::new(token_account, false),
                AccountMeta::new_readonly(token_mint, false),
                AccountMeta::new(self.keypair.pubkey(), true),
                AccountMeta::new_readonly(spl_token::id(), false),
            ],
            data: borsh::to_vec(&data)?,
        })
    }

    fn build_swap_instruction(
        &self,
        leg: &SwapLeg,
        amount: u64,
    ) -> std::result::Result<Instruction, anyhow::Error> {
        match leg.program_id.to_string().as_str() {
            RAYDIUM_V4_PROGRAM_ID => self.build_raydium_swap(leg, amount),
            ORCA_WHIRLPOOL_PROGRAM_ID => self.build_orca_swap(leg, amount),
            _ => Err(anyhow::anyhow!("Invalid program ID")),
        }
    }

    fn build_raydium_swap(
        &self,
        leg: &SwapLeg,
        amount: u64,
    ) -> std::result::Result<Instruction, anyhow::Error> {
        let user_source_token = get_associated_token_address(&self.keypair.pubkey(), &leg.input_mint);
        let user_dest_token = get_associated_token_address(&self.keypair.pubkey(), &leg.output_mint);
        
        let mut data = vec![9]; // Raydium swap instruction discriminator
        data.extend_from_slice(&amount.to_le_bytes());
        data.extend_from_slice(&0u64.to_le_bytes()); // minimum amount out
        
        Ok(Instruction {
            program_id: leg.program_id,
            accounts: vec![
                AccountMeta::new_readonly(spl_token::id(), false),
                AccountMeta::new(leg.pool_address, false),
                AccountMeta::new_readonly(Pubkey::find_program_address(
                    &[b"authority", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new_readonly(Pubkey::find_program_address(
                    &[b"vault", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new(Pubkey::find_program_address(
                    &[b"vault_a", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new(Pubkey::find_program_address(
                    &[b"vault_b", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new_readonly(Pubkey::find_program_address(
                    &[b"serum_market", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new(user_source_token, false),
                AccountMeta::new(user_dest_token, false),
                AccountMeta::new(self.keypair.pubkey(), true),
            ],
            data,
        })
    }

    fn build_orca_swap(
        &self,
        leg: &SwapLeg,
        amount: u64,
    ) -> std::result::Result<Instruction, anyhow::Error> {
        let user_source_token = get_associated_token_address(&self.keypair.pubkey(), &leg.input_mint);
        let user_dest_token = get_associated_token_address(&self.keypair.pubkey(), &leg.output_mint);
        
        let sqrt_price_limit = match leg.direction {
            SwapDirection::AToB => 4295128739u64,
            SwapDirection::BToA => 79226673515401279992447579055u128 as u64,
        };
        
        let mut data = vec![0xf8, 0xc6, 0x9e, 0x91, 0x8a, 0x14, 0x38, 0x6c]; // swap discriminator
        data.extend_from_slice(&amount.to_le_bytes());
        data.extend_from_slice(&0u64.to_le_bytes()); // other_amount_threshold
        data.extend_from_slice(&sqrt_price_limit.to_le_bytes());
        data.push(match leg.direction {
            SwapDirection::AToB => 1,
            SwapDirection::BToA => 0,
        });
        data.push(1); // amount_specified_is_input
        
        let tick_array_0 = Pubkey::find_program_address(
            &[b"tick_array", leg.pool_address.as_ref(), &0i32.to_le_bytes()],
            &leg.program_id,
        ).0;
        
        let tick_array_1 = Pubkey::find_program_address(
            &[b"tick_array", leg.pool_address.as_ref(), &1i32.to_le_bytes()],
            &leg.program_id,
        ).0;
        
        let tick_array_2 = Pubkey::find_program_address(
            &[b"tick_array", leg.pool_address.as_ref(), &2i32.to_le_bytes()],
            &leg.program_id,
        ).0;
        
        Ok(Instruction {
            program_id: leg.program_id,
            accounts: vec![
                AccountMeta::new_readonly(spl_token::id(), false),
                AccountMeta::new(self.keypair.pubkey(), true),
                AccountMeta::new(leg.pool_address, false),
                AccountMeta::new(user_source_token, false),
                AccountMeta::new(Pubkey::find_program_address(
                    &[b"vault_a", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new(user_dest_token, false),
                AccountMeta::new(Pubkey::find_program_address(
                    &[b"vault_b", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
                AccountMeta::new(tick_array_0, false),
                AccountMeta::new(tick_array_1, false),
                AccountMeta::new(tick_array_2, false),
                AccountMeta::new_readonly(Pubkey::find_program_address(
                    &[b"oracle", leg.pool_address.as_ref()],
                    &leg.program_id,
                ).0, false),
            ],
            data,
        })
    }

    fn build_flash_loan_end(&self) -> std::result::Result<Instruction, anyhow::Error> {
        let solend_program = Pubkey::from_str(SOLEND_PROGRAM_ID).map_err(|_| anchor_lang::error::Error::from(anchor_lang::error::ErrorCode::InvalidProgramId))?;
        
        let data = SolendFlashLoanEnd {
            instruction: 15,
        };
        
        Ok(Instruction {
            program_id: solend_program,
            accounts: vec![
                AccountMeta::new(self.keypair.pubkey(), true),
                AccountMeta::new_readonly(spl_token::id(), false),],
            data: borsh::to_vec(&data)?,

        })
    }




    #[tokio::test]
    async fn test_priority_fee_calculation() {
        let bot = FrontrunFlashLoanWeaponizer::new(
            "https://api.mainnet-beta.solana.com",
            "wss://api.mainnet-beta.solana.com",
            Keypair::new(),
        ).await.unwrap();
        
        let fee = bot.calculate_dynamic_priority_fee(100_000_000);
        assert!(fee >= BASE_PRIORITY_FEE);
        assert!(fee <= 50_000_000);
    }

