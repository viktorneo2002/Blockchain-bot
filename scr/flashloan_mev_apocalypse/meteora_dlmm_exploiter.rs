use anchor_lang::prelude::*;
use anchor_lang::solana_program::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    system_program,
};
use borsh::{BorshDeserialize, BorshSerialize};
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    compute_budget::ComputeBudgetInstruction,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use spl_associated_token_account::get_associated_token_address;
use std::collections::HashMap;
use std::str::FromStr;
use std::sync::Arc;
use tokio::sync::RwLock;

const METEORA_PROGRAM: &str = "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo";
const PYTH_PROGRAM: &str = "FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH";
const MIN_PROFIT: u64 = 100_000;
const PRIORITY_FEE: u64 = 50_000;

#[repr(C)]
#[derive(Debug, Clone, Copy, BorshSerialize, BorshDeserialize)]
pub struct LbPair {
    pub parameters: Parameters,
    pub v_parameters: VParameters,
    pub bump_seed: [u8; 1],
    pub bin_step: u16,
    pub pair_type: u8,
    pub active_id: i32,
    pub bin_array_bitmap: [u64; 16],
    pub oracle: Pubkey,
    pub reserves: [u64; 2],
    pub mint_x: Pubkey,
    pub mint_y: Pubkey,
    pub reserve_x: Pubkey,
    pub reserve_y: Pubkey,
    pub fee_owner: Pubkey,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, BorshSerialize, BorshDeserialize)]
pub struct Parameters {
    pub base_factor: u16,
    pub filter_period: u16,
    pub decay_period: u16,
    pub reduction_factor: u16,
    pub variable_fee_control: u32,
    pub max_volatility: u32,
    pub min_bin_id: i32,
    pub max_bin_id: i32,
    pub protocol_share: u16,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, BorshSerialize, BorshDeserialize)]
pub struct VParameters {
    pub volatility: u32,
    pub reference: u32,
    pub id_reference: i32,
    pub time_last_update: i64,
    pub oracle_id: i32,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct BinArray {
    pub version: u8,
    pub padding: [u8; 7],
    pub lb_pair: Pubkey,
    pub bins: [[u64; 4]; 70],
}

impl BinArray {
    fn decode(data: &[u8]) -> Result<Self, Box<dyn std::error::Error>> {
        if data.len() < 2248 {
            return Err("Invalid bin array data".into());
        }
        
        let mut bins = [[0u64; 4]; 70];
        let bin_data = &data[40..];
        
        for i in 0..70 {
            let offset = i * 32;
            if offset + 32 <= bin_data.len() {
                for j in 0..4 {
                    bins[i][j] = u64::from_le_bytes(
                        bin_data[offset + j * 8..offset + (j + 1) * 8]
                            .try_into()?
                    );
                }
            }
        }
        
        Ok(BinArray {
            version: data[0],
            padding: [0; 7],
            lb_pair: Pubkey::try_from(&data[8..40])?,
            bins,
        })
    }
}

#[derive(Debug, Clone)]
pub struct PriceData {
    pub price: f64,
    pub confidence: f64,
    pub expo: i32,
    pub timestamp: i64,
}

impl PriceData {
    fn from_pyth_account(data: &[u8]) -> Result<Self, Box<dyn std::error::Error>> {
        if data.len() < 256 {
            return Err("Invalid price account".into());
        }
        
        let price = i64::from_le_bytes(data[208..216].try_into()?);
        let confidence = u64::from_le_bytes(data[216..224].try_into()?);
        let expo = i32::from_le_bytes(data[228..232].try_into()?);
        let timestamp = i64::from_le_bytes(data[240..248].try_into()?);
        
        Ok(PriceData {
            price: price as f64 * 10f64.powi(expo),
            confidence: confidence as f64 * 10f64.powi(expo),
            expo,
            timestamp,
        })
    }
}

#[derive(Debug, Clone)]
pub struct Opportunity {
    pub pool: Pubkey,
    pub profit: u64,
    pub amount_in: u64,
    pub amount_out: u64,
    pub strategy: Strategy,
}

#[derive(Debug, Clone)]
pub enum Strategy {
    Arbitrage { swap_for_y: bool },
    Sandwich { victim_sig: String, victim_amount: u64 },
    JIT { bin_id: i32, fee_income: u64 },
}

pub struct MeteoraExploiter {
    rpc: Arc<RpcClient>,
    wallet: Arc<Keypair>,
    pools: Arc<RwLock<HashMap<Pubkey, LbPair>>>,
    bin_arrays: Arc<RwLock<HashMap<Pubkey, Vec<BinArray>>>>,
    prices: Arc<RwLock<HashMap<Pubkey, PriceData>>>,
}

impl MeteoraExploiter {
    pub fn new(rpc_url: &str, wallet: Keypair) -> Self {
        Self {
            rpc: Arc::new(RpcClient::new(rpc_url.to_string())),
            wallet: Arc::new(wallet),
            pools: Arc::new(RwLock::new(HashMap::new())),
            bin_arrays: Arc::new(RwLock::new(HashMap::new())),
            prices: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn load_pool(&self, pool_key: Pubkey) -> Result<(), Box<dyn std::error::Error>> {
        let account = self.rpc.get_account(&pool_key).await?;
        let pool = LbPair::try_from_slice(&account.data)?;
        
        let mut bin_arrays = Vec::new();
        for i in 0..1024 {
            let word_idx = i / 64;
            let bit_idx = i % 64;
            
            if word_idx < 16 && (pool.bin_array_bitmap[word_idx] & (1u64 << bit_idx)) != 0 {
                let (bin_array_key, _) = Pubkey::find_program_address(
                    &[b"bin_array", pool_key.as_ref(), &i.to_le_bytes()],
                    &Pubkey::from_str(METEORA_PROGRAM)?,
                );
                
                if let Ok(bin_account) = self.rpc.get_account(&bin_array_key).await {
                    if let Ok(bin_array) = BinArray::decode(&bin_account.data) {
                        bin_arrays.push(bin_array);
                    }
                }
            }
        }
        
        self.pools.write().await.insert(pool_key, pool);
        self.bin_arrays.write().await.insert(pool_key, bin_arrays);
        
        self.update_price(&pool.mint_x).await?;
        self.update_price(&pool.mint_y).await?;
        
        Ok(())
    }

    async fn update_price(&self, mint: &Pubkey) -> Result<(), Box<dyn std::error::Error>> {
        let oracle_key = match mint.to_string().as_str() {
            "So11111111111111111111111111111111111111112" => "H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG",
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" => "Gnt27xtC473ZT2Mw5u8wZ68Z3gULkSTb5DuxJy7eJotD",
            "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So" => "E4v1BBgoso9s64TQvmyownAVJbhbEPGyzA3qn4n46qj9",
            _ => return Ok(()),
        };
        
        if let Ok(oracle_account) = self.rpc.get_account(&Pubkey::from_str(oracle_key)?).await {
            if let Ok(price_data) = PriceData::from_pyth_account(&oracle_account.data) {
                self.prices.write().await.insert(*mint, price_data);
            }
        }
        
        Ok(())
    }

    pub async fn find_opportunities(&self) -> Vec<Opportunity> {
        let mut opportunities = Vec::new();
        let pools = self.pools.read().await;
        
        for (pool_key, pool) in pools.iter() {
            if let Some(arb) = self.check_arbitrage(pool_key, pool).await {
                opportunities.push(arb);
            }
            
            if let Some(mut sandwich_opps) = self.check_sandwich(pool_key, pool).await {
                opportunities.append(&mut sandwich_opps);
            }
            
            if let Some(jit) = self.check_jit(pool_key, pool).await {
                opportunities.push(jit);
            }
        }
        
        opportunities.sort_by(|a, b| b.profit.cmp(&a.profit));
        opportunities
    }

    async fn check_arbitrage(&self, pool_key: &Pubkey, pool: &LbPair) -> Option<Opportunity> {
        let prices = self.prices.read().await;
        let price_x = prices.get(&pool.mint_x)?;
        let price_y = prices.get(&pool.mint_y)?;
        
        let market_price = price_x.price / price_y.price;
        let pool_price = self.calculate_price(pool.active_id, pool.bin_step);
        let price_diff = ((pool_price - market_price) / market_price).abs();
        
        if price_diff < 0.002 {
            return None;
        }
        
        let swap_for_y = pool_price > market_price;
        let test_amounts = [1_000_000u64, 10_000_000, 100_000_000, 500_000_000];
        
        for &amount in &test_amounts {
            if let Some((amount_out, _)) = self.simulate_swap(pool_key, pool, amount, swap_for_y).await {
                let value_in = amount as f64 * if swap_for_y { price_x.price } else { price_y.price };
                let value_out = amount_out as f64 * if swap_for_y { price_y.price } else { price_x.price };
                let profit = (value_out - value_in) as i64;
                
                if profit > MIN_PROFIT as i64 {
                    return Some(Opportunity {
                        pool: *pool_key,
                        profit: profit as u64,
                        amount_in: amount,
                        amount_out,
                        strategy: Strategy::Arbitrage { swap_for_y },
                    });
                }
            }
        }
        
        None
    }

    async fn check_sandwich(&self, pool_key: &Pubkey, pool: &LbPair) -> Option<Vec<Opportunity>> {
        let pending = self.get_pending_transactions(pool_key).await.ok()?;
        let mut opportunities = Vec::new();
        
        for (sig, victim_amount, swap_for_y) in pending {
            let (impact_out, _) = self.simulate_swap(pool_key, pool, victim_amount, swap_for_y).await?;
            let impact = 1.0 - (impact_out as f64 / victim_amount as f64);
            
            if impact > 0.005 && impact < 0.10 {
                let front_amount = (victim_amount as f64 * impact * 2.0) as u64;
                
                if let Some((front_out, bins_after_front)) = self.simulate_swap(pool_key, pool, front_amount, swap_for_y).await {
                    let temp_pool = LbPair { active_id: bins_after_front, ..*pool };
                    
                    if let Some((_, bins_after_victim)) = self.simulate_swap_with_state(pool_key, &temp_pool, victim_amount, swap_for_y).await {
                        let temp_pool2 = LbPair { active_id: bins_after_victim, ..*pool };
                        
                        if let Some((back_out, _)) = self.simulate_swap_with_state(pool_key, &temp_pool2, front_out, !swap_for_y).await {
                            let profit = back_out.saturating_sub(front_amount);
                            
                            if profit > MIN_PROFIT {
                                opportunities.push(Opportunity {
                                    pool: *pool_key,
                                    profit,
                                    amount_in: front_amount,
                                    amount_out: front_out,
                                    strategy: Strategy::Sandwich { victim_sig: sig, victim_amount },
                                });
                            }
                        }
                    }
                }
            }
        }
        
        Some(opportunities)
    }

    async fn check_jit(&self, pool_key: &Pubkey, pool: &LbPair) -> Option<Opportunity> {
                let pending = self.get_pending_transactions(pool_key).await.ok()?;
        
        for (_, amount, swap_for_y) in pending {
            if amount < 100_000_000 {
                continue;
            }
            
            let target_bin = if swap_for_y {
                pool.active_id - 1
            } else {
                pool.active_id + 1
            };
            
            let base_fee = pool.parameters.base_factor as u64;
            let var_fee = (pool.v_parameters.volatility as u64 * pool.parameters.variable_fee_control as u64) / 100_000;
            let total_fee = base_fee + var_fee;
            let fee_income = (amount * total_fee) / 10_000;
            
            if fee_income > MIN_PROFIT * 2 {
                return Some(Opportunity {
                    pool: *pool_key,
                    profit: fee_income,
                    amount_in: amount / 2,
                    amount_out: amount / 2,
                    strategy: Strategy::JIT { bin_id: target_bin, fee_income },
                });
            }
        }
        
        None
    }

    fn calculate_price(&self, bin_id: i32, bin_step: u16) -> f64 {
        let base = 1.0 + (bin_step as f64 / 10_000.0);
        base.powi(bin_id)
    }

    async fn simulate_swap(&self, pool_key: &Pubkey, pool: &LbPair, amount_in: u64, swap_for_y: bool) -> Option<(u64, i32)> {
        self.simulate_swap_with_state(pool_key, pool, amount_in, swap_for_y).await
    }

    async fn simulate_swap_with_state(&self, pool_key: &Pubkey, pool: &LbPair, amount_in: u64, swap_for_y: bool) -> Option<(u64, i32)> {
        let bin_arrays = self.bin_arrays.read().await;
        let arrays = bin_arrays.get(pool_key)?;
        
        let mut remaining = amount_in;
        let mut amount_out = 0u64;
        let mut current_id = pool.active_id;
        
        let base_fee = pool.parameters.base_factor as u128;
        let var_fee = (pool.v_parameters.volatility as u128 * pool.parameters.variable_fee_control as u128) / 100_000;
        let total_fee = base_fee + var_fee;
        
        while remaining > 0 {
            let bin_data = self.get_bin_reserves(arrays, current_id)?;
            let (reserve_in, reserve_out) = if swap_for_y {
                (bin_data[0], bin_data[1])
            } else {
                (bin_data[1], bin_data[0])
            };
            
            if reserve_out == 0 {
                current_id = if swap_for_y { current_id - 1 } else { current_id + 1 };
                continue;
            }
            
            let price = self.calculate_price(current_id, pool.bin_step);
            let max_amount_in = if swap_for_y {
                (reserve_out as f64 / price) as u64
            } else {
                (reserve_out as f64 * price) as u64
            };
            
            let amount_to_swap = remaining.min(max_amount_in);
            let fee_amount = (amount_to_swap as u128 * total_fee / 10_000) as u64;
            let amount_after_fee = amount_to_swap - fee_amount;
            
            let out_from_bin = if swap_for_y {
                (amount_after_fee as f64 * price) as u64
            } else {
                (amount_after_fee as f64 / price) as u64
            };
            
            amount_out += out_from_bin;
            remaining -= amount_to_swap;
            
            if remaining > 0 {
                current_id = if swap_for_y { current_id - 1 } else { current_id + 1 };
            }
        }
        
        if remaining == 0 {
            Some((amount_out, current_id))
        } else {
            None
        }
    }

    fn get_bin_reserves(&self, arrays: &[BinArray], bin_id: i32) -> Option<[u64; 4]> {
        let bin_array_idx = bin_id / 70;
        let bin_idx = bin_id % 70;
        
        for array in arrays {
            let array_base_id = bin_array_idx * 70;
            if bin_id >= array_base_id && bin_id < array_base_id + 70 {
                return Some(array.bins[bin_idx as usize]);
            }
        }
        None
    }

    async fn get_pending_transactions(&self, pool: &Pubkey) -> Result<Vec<(String, u64, bool)>, Box<dyn std::error::Error>> {
        let sigs = self.rpc.get_signatures_for_address(pool).await?;
        let mut pending = Vec::new();
        
        for sig in sigs.iter().take(10) {
            let sig_str = sig.signature.clone();
            if let Ok(tx) = self.rpc.get_transaction(
                &sig_str.parse()?,
                solana_transaction_status::UiTransactionEncoding::Base64,
            ).await {
                if let Some(meta) = tx.transaction.meta {
                    if meta.err.is_none() {
                        if let Some((amount, swap_for_y)) = self.decode_swap_tx(&tx) {
                            pending.push((sig_str, amount, swap_for_y));
                        }
                    }
                }
            }
        }
        
        Ok(pending)
    }

    fn decode_swap_tx(&self, tx: &solana_transaction_status::EncodedConfirmedTransactionWithStatusMeta) -> Option<(u64, bool)> {
        if let Some(transaction) = &tx.transaction.transaction {
            if let Ok(decoded) = transaction.decode() {
                for ix in &decoded.message.instructions {
                    if ix.program_id(decoded.message.static_account_keys()).to_string() == METEORA_PROGRAM {
                        if ix.data.len() >= 17 && ix.data[0] == 14 {
                            let amount = u64::from_le_bytes(ix.data[1..9].try_into().ok()?);
                            let swap_for_y = ix.data[16] != 0;
                            return Some((amount, swap_for_y));
                        }
                    }
                }
            }
        }
        None
    }

    pub async fn execute(&self, opp: &Opportunity) -> Result<String, Box<dyn std::error::Error>> {
        match &opp.strategy {
            Strategy::Arbitrage { swap_for_y } => {
                self.execute_swap(opp.pool, opp.amount_in, opp.amount_out, *swap_for_y).await
            }
            Strategy::Sandwich { .. } => {
                self.execute_sandwich(opp).await
            }
            Strategy::JIT { bin_id, .. } => {
                self.execute_jit(opp.pool, opp.amount_in, *bin_id).await
            }
        }
    }

    async fn execute_swap(&self, pool_key: Pubkey, amount_in: u64, min_out: u64, swap_for_y: bool) -> Result<String, Box<dyn std::error::Error>> {
        let pool = self.pools.read().await.get(&pool_key).cloned()
            .ok_or("Pool not found")?;
        
        let user_x = get_associated_token_address(&self.wallet.pubkey(), &pool.mint_x);
        let user_y = get_associated_token_address(&self.wallet.pubkey(), &pool.mint_y);
        
        let accounts = vec![
            AccountMeta::new(pool_key, false),
            AccountMeta::new(pool.reserves[0], false),
            AccountMeta::new(pool.reserves[1], false),
            AccountMeta::new(if swap_for_y { user_x } else { user_y }, false),
            AccountMeta::new(if swap_for_y { user_y } else { user_x }, false),
            AccountMeta::new_readonly(pool.mint_x, false),
            AccountMeta::new_readonly(pool.mint_y, false),
            AccountMeta::new(pool.oracle, false),
            AccountMeta::new_readonly(self.wallet.pubkey(), true),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new_readonly(pool.fee_owner, false),
        ];
        
        let mut data = vec![14u8];
        data.extend_from_slice(&amount_in.to_le_bytes());
        data.extend_from_slice(&min_out.to_le_bytes());
        data.push(swap_for_y as u8);
        
        let ix = Instruction {
            program_id: Pubkey::from_str(METEORA_PROGRAM)?,
            accounts,
            data,
        };
        
        let ixs = vec![
            ComputeBudgetInstruction::set_compute_unit_limit(400_000),
            ComputeBudgetInstruction::set_compute_unit_price(PRIORITY_FEE),
            ix,
        ];
        
        self.send_transaction(ixs).await
    }

    async fn execute_sandwich(&self, opp: &Opportunity) -> Result<String, Box<dyn std::error::Error>> {
        if let Strategy::Sandwich { .. } = &opp.strategy {
            let swap_for_y = match &opp.strategy {
                Strategy::Sandwich { .. } => true,
                _ => false,
            };
            
            let front_sig = self.execute_swap(opp.pool, opp.amount_in, opp.amount_out * 98 / 100, swap_for_y).await?;
            tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
            let back_sig = self.execute_swap(opp.pool, opp.amount_out, opp.amount_in * 98 / 100, !swap_for_y).await?;
            
            Ok(format!("{},{}", front_sig, back_sig))
        } else {
            Err("Invalid strategy".into())
        }
    }

    async fn execute_jit(&self, pool_key: Pubkey, amount: u64, bin_id: i32) -> Result<String, Box<dyn std::error::Error>> {
        let pool = self.pools.read().await.get(&pool_key).cloned()
            .ok_or("Pool not found")?;
        
        let program_id = Pubkey::from_str(METEORA_PROGRAM)?;
        let (position, _) = Pubkey::find_program_address(
            &[b"position", pool_key.as_ref(), self.wallet.pubkey().as_ref()],
            &program_id,
        );
        
        let (bin_array, _) = Pubkey::find_program_address(
            &[b"bin_array", pool_key.as_ref(), &(bin_id / 70).to_le_bytes()],
            &program_id,
        );
        
        let user_x = get_associated_token_address(&self.wallet.pubkey(), &pool.mint_x);
        let user_y = get_associated_token_address(&self.wallet.pubkey(), &pool.mint_y);
        
        let mut add_liq_data = vec![6u8];
        add_liq_data.extend_from_slice(&[1u8]);
        add_liq_data.extend_from_slice(&bin_id.to_le_bytes());
        add_liq_data.extend_from_slice(&bin_id.to_le_bytes());
        add_liq_data.extend_from_slice(&amount.to_le_bytes());
        add_liq_data.extend_from_slice(&amount.to_le_bytes());
        add_liq_data.extend_from_slice(&bin_id.to_le_bytes());
        add_liq_data.extend_from_slice(&10000u16.to_le_bytes());
        
        let add_liq_ix = Instruction {
            program_id,
            accounts: vec![
                AccountMeta::new(position, false),
                AccountMeta::new(pool_key, false),
                AccountMeta::new(bin_array, false),
                AccountMeta::new_readonly(self.wallet.pubkey(), true),
                AccountMeta::new(user_x, false),
                AccountMeta::new(user_y, false),
                AccountMeta::new(pool.reserve_x, false),
                AccountMeta::new(pool.reserve_y, false),
                AccountMeta::new_readonly(pool.mint_x, false),
                AccountMeta::new_readonly(pool.mint_y, false),
                AccountMeta::new_readonly(spl_token::id(), false),
                AccountMeta::new(pool.oracle, false),
            ],
            data: add_liq_data,
        };
        
        let mut remove_liq_data = vec![7u8];
        remove_liq_data.extend_from_slice(&[1u8]);
        remove_liq_data.extend_from_slice(&bin_id.to_le_bytes());
        remove_liq_data.extend_from_slice(&10000u16.to_le_bytes());
        
        let remove_liq_ix = Instruction {
            program_id,
            accounts: vec![
                AccountMeta::new(position, false),
                AccountMeta::new(pool_key, false),
                AccountMeta::new(bin_array, false),
                AccountMeta::new_readonly(self.wallet.pubkey(), true),
                AccountMeta::new(user_x, false),
                AccountMeta::new(user_y, false),
                AccountMeta::new(pool.reserve_x, false),
                AccountMeta::new(pool.reserve_y, false),
                AccountMeta::new_readonly(pool.mint_x, false),
                AccountMeta::new_readonly(pool.mint_y, false),
                AccountMeta::new_readonly(spl_token::id(), false),
                AccountMeta::new(pool.oracle, false),
            ],
            data: remove_liq_data,
        };
        
        let ixs = vec![
            ComputeBudgetInstruction::set_compute_unit_limit(600_000),
            ComputeBudgetInstruction::set_compute_unit_price(PRIORITY_FEE * 2),
            add_liq_ix,
            remove_liq_ix,
        ];
        
        self.send_transaction(ixs).await
    }

        async fn send_transaction(&self, instructions: Vec<Instruction>) -> Result<String, Box<dyn std::error::Error>> {
        let recent_blockhash = self.rpc.get_latest_blockhash().await?;
        
        let tx = Transaction::new_signed_with_payer(
            &instructions,
            Some(&self.wallet.pubkey()),
            &[&*self.wallet],
            recent_blockhash,
        );
        
        let config = solana_client::rpc_config::RpcSendTransactionConfig {
            skip_preflight: true,
            preflight_commitment: Some(CommitmentConfig::processed()),
            encoding: Some(solana_transaction_status::UiTransactionEncoding::Base64),
            max_retries: Some(3),
            min_context_slot: None,
        };
        
        let sig = self.rpc.send_transaction_with_config(&tx, config).await?;
        
        let start = std::time::Instant::now();
        loop {
            if start.elapsed().as_secs() > 30 {
                return Err("Transaction timeout".into());
            }
            
            match self.rpc.get_signature_status(&sig).await? {
                Some(Ok(_)) => return Ok(sig.to_string()),
                Some(Err(e)) => return Err(format!("Transaction failed: {:?}", e).into()),
                None => tokio::time::sleep(tokio::time::Duration::from_millis(100)).await,
            }
        }
    }

    pub async fn monitor(&self) -> Result<(), Box<dyn std::error::Error>> {
        println!("Starting Meteora DLMM monitor...");
        
        loop {
            let opportunities = self.find_opportunities().await;
            
            for opp in opportunities.iter().take(5) {
                println!("Opportunity: {:?} Profit: {} lamports", opp.strategy, opp.profit);
                
                if opp.profit > MIN_PROFIT {
                    match self.execute(opp).await {
                        Ok(sig) => println!("✅ Executed: {}", sig),
                        Err(e) => eprintln!("❌ Failed: {}", e),
                    }
                }
            }
            
            for pool in self.pools.read().await.keys() {
                if let Err(e) = self.load_pool(*pool).await {
                    eprintln!("Failed to reload pool: {}", e);
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
    }
}

