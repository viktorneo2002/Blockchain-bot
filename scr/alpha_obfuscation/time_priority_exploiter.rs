use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};
use std::collections::{HashMap, BTreeMap, VecDeque};
use std::cmp::Ordering;
use solana_client::rpc_client::RpcClient;
use solana_client::rpc_config::{RpcSendTransactionConfig, RpcSimulateTransactionConfig};
use solana_sdk::{
    commitment_config::{CommitmentConfig, CommitmentLevel},
    compute_budget::ComputeBudgetInstruction,
    instruction::Instruction,
    message::Message,
    pubkey::Pubkey,
    signature::{Keypair, Signature},
    signer::Signer,
    transaction::{Transaction, VersionedTransaction},
    hash::Hash,
};
use tokio::sync::{Mutex, mpsc};
use tokio::time::{sleep, timeout};
use serde::{Deserialize, Serialize};

const SLOT_DURATION_MS: u64 = 400;
const MAX_RETRIES: u32 = 3;
const BASE_PRIORITY_FEE: u64 = 1000;
const MAX_PRIORITY_FEE: u64 = 2_000_000;
const PRIORITY_FEE_PERCENTILE: f64 = 0.95;
const SLOT_BUFFER_MS: u64 = 50;
const TX_EXPIRY_SLOTS: u64 = 150;
const MAX_PENDING_TXS: usize = 100;
const PRIORITY_WINDOW_SIZE: usize = 20;
const MIN_PROFIT_THRESHOLD: u64 = 100_000;
const COMPETITION_DECAY_FACTOR: f64 = 0.95;
const LATENCY_BUFFER_MS: u64 = 10;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimePriorityConfig {
    pub rpc_url: String,
    pub ws_url: String,
    pub payer_keypair: Arc<Keypair>,
    pub max_priority_fee: u64,
    pub slot_timing_offset: i64,
    pub competition_threshold: f64,
    pub adaptive_fee_enabled: bool,
}

#[derive(Debug, Clone)]
pub struct SlotInfo {
    pub slot: u64,
    pub timestamp: Instant,
    pub leader: Pubkey,
    pub bank_hash: Hash,
}

#[derive(Debug, Clone)]
pub struct PriorityMetrics {
    pub slot: u64,
    pub avg_priority_fee: u64,
    pub max_priority_fee: u64,
    pub success_rate: f64,
    pub competition_score: f64,
}

#[derive(Debug, Clone)]
pub struct TransactionOpportunity {
    pub id: String,
    pub transaction: Transaction,
    pub priority_fee: u64,
    pub expected_profit: u64,
    pub submission_slot: u64,
    pub expiry_slot: u64,
    pub retry_count: u32,
    pub created_at: Instant,
}

pub struct TimePriorityExploiter {
    config: TimePriorityConfig,
    rpc_client: Arc<RpcClient>,
    slot_tracker: Arc<RwLock<SlotInfo>>,
    priority_history: Arc<RwLock<VecDeque<PriorityMetrics>>>,
    pending_txs: Arc<Mutex<HashMap<String, TransactionOpportunity>>>,
    tx_sender: mpsc::Sender<TransactionOpportunity>,
    tx_receiver: Arc<Mutex<mpsc::Receiver<TransactionOpportunity>>>,
    competition_tracker: Arc<RwLock<BTreeMap<u64, f64>>>,
}

impl TimePriorityExploiter {
    pub fn new(config: TimePriorityConfig) -> Self {
        let rpc_client = Arc::new(RpcClient::new_with_commitment(
            config.rpc_url.clone(),
            CommitmentConfig::confirmed(),
        ));
        
        let (tx_sender, tx_receiver) = mpsc::channel(MAX_PENDING_TXS);
        
        Self {
            config,
            rpc_client,
            slot_tracker: Arc::new(RwLock::new(SlotInfo {
                slot: 0,
                timestamp: Instant::now(),
                leader: Pubkey::default(),
                bank_hash: Hash::default(),
            })),
            priority_history: Arc::new(RwLock::new(VecDeque::with_capacity(PRIORITY_WINDOW_SIZE))),
            pending_txs: Arc::new(Mutex::new(HashMap::new())),
            tx_sender,
            tx_receiver: Arc::new(Mutex::new(tx_receiver)),
            competition_tracker: Arc::new(RwLock::new(BTreeMap::new())),
        }
    }

    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let slot_handle = self.spawn_slot_tracker();
        let priority_handle = self.spawn_priority_tracker();
        let submission_handle = self.spawn_transaction_submitter();
        
        tokio::try_join!(slot_handle, priority_handle, submission_handle)?;
        Ok(())
    }

    fn spawn_slot_tracker(&self) -> tokio::task::JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>> {
        let rpc_client = self.rpc_client.clone();
        let slot_tracker = self.slot_tracker.clone();
        
        tokio::spawn(async move {
            let mut last_slot = 0u64;
            
            loop {
                match rpc_client.get_slot_with_commitment(CommitmentConfig::processed()) {
                    Ok(slot) => {
                        if slot > last_slot {
                            let leader = rpc_client.get_slot_leader()
                                .unwrap_or_else(|_| Pubkey::default());
                            
                            let mut tracker = slot_tracker.write().unwrap();
                            tracker.slot = slot;
                            tracker.timestamp = Instant::now();
                            tracker.leader = leader;
                            
                            last_slot = slot;
                        }
                    }
                    Err(e) => {
                        eprintln!("Slot tracking error: {:?}", e);
                    }
                }
                
                sleep(Duration::from_millis(50)).await;
            }
        })
    }

    fn spawn_priority_tracker(&self) -> tokio::task::JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>> {
        let rpc_client = self.rpc_client.clone();
        let priority_history = self.priority_history.clone();
        let competition_tracker = self.competition_tracker.clone();
        
        tokio::spawn(async move {
            loop {
                match Self::fetch_current_priority_fees(&rpc_client).await {
                    Ok(metrics) => {
                        let mut history = priority_history.write().unwrap();
                        if history.len() >= PRIORITY_WINDOW_SIZE {
                            history.pop_front();
                        }
                        
                        let mut competition = competition_tracker.write().unwrap();
                        competition.insert(metrics.slot, metrics.competition_score);
                        
                        // Clean old competition data
                        let cutoff_slot = metrics.slot.saturating_sub(50);
                        competition.retain(|&slot, _| slot > cutoff_slot);
                        
                        history.push_back(metrics);
                    }
                    Err(e) => {
                        eprintln!("Priority tracking error: {:?}", e);
                    }
                }
                
                sleep(Duration::from_millis(200)).await;
            }
        })
    }

    async fn fetch_current_priority_fees(rpc_client: &RpcClient) -> Result<PriorityMetrics, Box<dyn std::error::Error + Send + Sync>> {
        let slot = rpc_client.get_slot_with_commitment(CommitmentConfig::processed())?;
        let recent_fees = rpc_client.get_recent_prioritization_fees(&[])?;
        
        if recent_fees.is_empty() {
            return Ok(PriorityMetrics {
                slot,
                avg_priority_fee: BASE_PRIORITY_FEE,
                max_priority_fee: BASE_PRIORITY_FEE * 2,
                success_rate: 0.5,
                competition_score: 0.5,
            });
        }
        
        let mut fees: Vec<u64> = recent_fees.iter()
            .map(|f| f.prioritization_fee)
            .collect();
        fees.sort_unstable();
        
        let percentile_idx = ((fees.len() as f64 * PRIORITY_FEE_PERCENTILE) as usize).min(fees.len() - 1);
        let avg_fee = fees.iter().sum::<u64>() / fees.len() as u64;
        let max_fee = *fees.last().unwrap_or(&BASE_PRIORITY_FEE);
        
        let competition_score = (fees[percentile_idx] as f64 / MAX_PRIORITY_FEE as f64).min(1.0);
        
        Ok(PriorityMetrics {
            slot,
            avg_priority_fee: avg_fee,
            max_priority_fee: max_fee,
            success_rate: 0.7,
            competition_score,
        })
    }

    fn spawn_transaction_submitter(&self) -> tokio::task::JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>> {
        let rpc_client = self.rpc_client.clone();
        let slot_tracker = self.slot_tracker.clone();
        let tx_receiver = self.tx_receiver.clone();
        let pending_txs = self.pending_txs.clone();
        let config = self.config.clone();
        
        tokio::spawn(async move {
            let mut receiver = tx_receiver.lock().await;
            
            while let Some(mut opportunity) = receiver.recv().await {
                let slot_info = slot_tracker.read().unwrap().clone();
                
                // Calculate optimal submission timing
                let slot_progress = Instant::now().duration_since(slot_info.timestamp).as_millis() as u64;
                let optimal_delay = Self::calculate_submission_delay(slot_progress, &opportunity);
                
                if optimal_delay > 0 {
                    sleep(Duration::from_millis(optimal_delay)).await;
                }
                
                // Update transaction with current blockhash
                match rpc_client.get_latest_blockhash_with_commitment(CommitmentConfig::processed()) {
                    Ok((blockhash, _)) => {
                        opportunity.transaction.message.recent_blockhash = blockhash;
                        
                        // Add priority fee instructions
                        let priority_ix = ComputeBudgetInstruction::set_compute_unit_price(opportunity.priority_fee);
                        let cu_limit_ix = ComputeBudgetInstruction::set_compute_unit_limit(1_400_000);
                        
                        let mut instructions = vec![priority_ix, cu_limit_ix];
                        instructions.extend(opportunity.transaction.message.instructions.clone());
                        
                        let message = Message::new_with_blockhash(
                            &instructions,
                            Some(&config.payer_keypair.pubkey()),
                            &blockhash,
                        );
                        
                        let tx = Transaction::new(&[config.payer_keypair.as_ref()], message, blockhash);
                        
                        // Submit transaction
                        match Self::submit_transaction_with_retry(&rpc_client, &tx, &opportunity).await {
                            Ok(signature) => {
                                let mut txs = pending_txs.lock().await;
                                txs.insert(signature.to_string(), opportunity.clone());
                            }
                            Err(e) => {
                                eprintln!("Transaction submission failed: {:?}", e);
                                
                                if opportunity.retry_count < MAX_RETRIES {
                                    opportunity.retry_count += 1;
                                    opportunity.priority_fee = (opportunity.priority_fee as f64 * 1.5) as u64;
                                    
                                    let mut txs = pending_txs.lock().await;
                                    txs.insert(opportunity.id.clone(), opportunity);
                                }
                            }
                        }
                    }
                    Err(e) => {
                        eprintln!("Failed to get blockhash: {:?}", e);
                    }
                }
            }
            
            Ok(())
        })
    }

    fn calculate_submission_delay(slot_progress: u64, opportunity: &TransactionOpportunity) -> u64 {
        if slot_progress < SLOT_BUFFER_MS {
            // Early in slot - wait for optimal timing
            SLOT_BUFFER_MS - slot_progress
        } else if slot_progress > SLOT_DURATION_MS - LATENCY_BUFFER_MS {
            // Too late in slot - submit immediately for next slot
            0
        } else {
            // Optimal submission window
            0
        }
    }

    async fn submit_transaction_with_retry(
        rpc_client: &RpcClient,
        tx: &Transaction,
        opportunity: &TransactionOpportunity,
    ) -> Result<Signature, Box<dyn std::error::Error + Send + Sync>> {
        let config = RpcSendTransactionConfig {
            skip_preflight: true,
            preflight_commitment: Some(CommitmentLevel::Processed),
            encoding: None,
            max_retries: Some(0),
            min_context_slot: None,
        };
        
        let signature = rpc_client.send_transaction_with_config(tx, config)?;
        
        // Fast confirmation check
        for _ in 0..5 {
            match rpc_client.get_signature_status(&signature)? {
                Some(status) => {
                    if status.is_ok() {
                        return Ok(signature);
                    } else if status.is_err() {
                        return Err("Transaction failed".into());
                    }
                }
                None => {
                    sleep(Duration::from_millis(50)).await;
                }
            }
        }
        
        Ok(signature)
    }

        pub async fn submit_opportunity(&self, opportunity: TransactionOpportunity) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Validate opportunity profitability
        if opportunity.expected_profit < MIN_PROFIT_THRESHOLD {
            return Err("Opportunity below profit threshold".into());
        }
        
        // Check slot validity
        let current_slot = self.slot_tracker.read().unwrap().slot;
        if opportunity.submission_slot > current_slot + 2 {
            return Err("Opportunity submission slot too far in future".into());
        }
        
        // Calculate adaptive priority fee
        let adaptive_fee = self.calculate_adaptive_priority_fee(&opportunity).await?;
        let mut updated_opportunity = opportunity;
        updated_opportunity.priority_fee = adaptive_fee.min(self.config.max_priority_fee);
        
        // Send to submission queue
        self.tx_sender.send(updated_opportunity).await
            .map_err(|e| format!("Failed to queue opportunity: {}", e))?;
        
        Ok(())
    }

    async fn calculate_adaptive_priority_fee(&self, opportunity: &TransactionOpportunity) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        let priority_history = self.priority_history.read().unwrap();
        if priority_history.is_empty() {
            return Ok(opportunity.priority_fee);
        }
        
        // Get recent competition metrics
        let recent_metrics: Vec<&PriorityMetrics> = priority_history.iter()
            .rev()
            .take(5)
            .collect();
        
        let avg_competition = recent_metrics.iter()
            .map(|m| m.competition_score)
            .sum::<f64>() / recent_metrics.len() as f64;
        
        let avg_max_fee = recent_metrics.iter()
            .map(|m| m.max_priority_fee)
            .sum::<u64>() / recent_metrics.len() as u64;
        
        // Calculate base fee from profit margin
        let profit_margin = opportunity.expected_profit as f64 / 1_000_000.0; // In SOL
        let base_fee = (profit_margin * 0.1 * 1_000_000.0) as u64; // 10% of profit for priority
        
        // Apply competition multiplier
        let competition_multiplier = 1.0 + (avg_competition * 2.0);
        let adaptive_fee = (base_fee as f64 * competition_multiplier) as u64;
        
        // Apply percentile targeting
        let target_fee = if avg_competition > self.config.competition_threshold {
            (avg_max_fee as f64 * PRIORITY_FEE_PERCENTILE) as u64
        } else {
            adaptive_fee
        };
        
        Ok(target_fee.max(BASE_PRIORITY_FEE).min(MAX_PRIORITY_FEE))
    }

    pub async fn analyze_slot_timing(&self, target_slot: u64) -> SlotTimingAnalysis {
        let current_slot_info = self.slot_tracker.read().unwrap().clone();
        let slot_diff = target_slot.saturating_sub(current_slot_info.slot);
        
        let time_until_slot = if slot_diff > 0 {
            let remaining_in_current = SLOT_DURATION_MS - 
                Instant::now().duration_since(current_slot_info.timestamp).as_millis() as u64;
            remaining_in_current + (slot_diff - 1) * SLOT_DURATION_MS
        } else {
            0
        };
        
        let optimal_submission_time = time_until_slot.saturating_sub(SLOT_BUFFER_MS);
        
        SlotTimingAnalysis {
            current_slot: current_slot_info.slot,
            target_slot,
            time_until_slot_ms: time_until_slot,
            optimal_submission_time_ms: optimal_submission_time,
            slot_progress_pct: (Instant::now().duration_since(current_slot_info.timestamp).as_millis() as f64 
                / SLOT_DURATION_MS as f64 * 100.0).min(100.0),
        }
    }

    pub async fn get_competition_analysis(&self) -> CompetitionAnalysis {
        let priority_history = self.priority_history.read().unwrap();
        let competition_tracker = self.competition_tracker.read().unwrap();
        
        if priority_history.is_empty() {
            return CompetitionAnalysis::default();
        }
        
        let recent_metrics: Vec<&PriorityMetrics> = priority_history.iter()
            .rev()
            .take(10)
            .collect();
        
        let current_competition = recent_metrics.first()
            .map(|m| m.competition_score)
            .unwrap_or(0.5);
        
        let avg_competition = recent_metrics.iter()
            .map(|m| m.competition_score)
            .sum::<f64>() / recent_metrics.len() as f64;
        
        let trend = if recent_metrics.len() >= 3 {
            let recent_avg = recent_metrics[..3].iter()
                .map(|m| m.competition_score)
                .sum::<f64>() / 3.0;
            let older_avg = recent_metrics[3..].iter()
                .map(|m| m.competition_score)
                .sum::<f64>() / (recent_metrics.len() - 3) as f64;
            
            if recent_avg > older_avg * 1.1 {
                CompetitionTrend::Increasing
            } else if recent_avg < older_avg * 0.9 {
                CompetitionTrend::Decreasing
            } else {
                CompetitionTrend::Stable
            }
        } else {
            CompetitionTrend::Stable
        };
        
        let recommended_fee = self.calculate_recommended_fee(current_competition, &trend);
        
        CompetitionAnalysis {
            current_score: current_competition,
            average_score: avg_competition,
            trend,
            recommended_priority_fee: recommended_fee,
            high_competition_slots: competition_tracker.iter()
                .filter(|(_, &score)| score > self.config.competition_threshold)
                .map(|(&slot, _)| slot)
                .collect(),
        }
    }

    fn calculate_recommended_fee(&self, competition: f64, trend: &CompetitionTrend) -> u64 {
        let base = (BASE_PRIORITY_FEE as f64 * (1.0 + competition * 10.0)) as u64;
        
        let adjusted = match trend {
            CompetitionTrend::Increasing => (base as f64 * 1.2) as u64,
            CompetitionTrend::Decreasing => (base as f64 * 0.9) as u64,
            CompetitionTrend::Stable => base,
        };
        
        adjusted.min(self.config.max_priority_fee)
    }

    pub async fn cleanup_expired_transactions(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let current_slot = self.slot_tracker.read().unwrap().slot;
        let mut pending = self.pending_txs.lock().await;
        
        pending.retain(|_, opportunity| {
            opportunity.expiry_slot > current_slot && 
            opportunity.created_at.elapsed() < Duration::from_secs(30)
        });
        
        Ok(())
    }

    pub fn create_opportunity(
        &self,
        id: String,
        instructions: Vec<Instruction>,
        expected_profit: u64,
    ) -> Result<TransactionOpportunity, Box<dyn std::error::Error + Send + Sync>> {
        let current_slot = self.slot_tracker.read().unwrap().slot;
        
        let message = Message::new_with_blockhash(
            &instructions,
            Some(&self.config.payer_keypair.pubkey()),
            &Hash::default(), // Will be updated during submission
        );
        
        let transaction = Transaction::new_unsigned(message);
        
        Ok(TransactionOpportunity {
            id,
            transaction,
            priority_fee: BASE_PRIORITY_FEE,
            expected_profit,
            submission_slot: current_slot + 1,
            expiry_slot: current_slot + TX_EXPIRY_SLOTS,
            retry_count: 0,
            created_at: Instant::now(),
        })
    }

    pub async fn monitor_transaction_status(&self, signature: &str) -> Result<TransactionStatus, Box<dyn std::error::Error + Send + Sync>> {
        let start = Instant::now();
        let timeout_duration = Duration::from_secs(30);
        
        while start.elapsed() < timeout_duration {
            match self.rpc_client.get_signature_status(signature) {
                Ok(Some(status)) => {
                    if let Ok(()) = status {
                        return Ok(TransactionStatus::Confirmed);
                    } else {
                        return Ok(TransactionStatus::Failed);
                    }
                }
                Ok(None) => {
                    if start.elapsed() > Duration::from_secs(5) {
                        return Ok(TransactionStatus::Expired);
                    }
                }
                Err(_) => {
                    // Continue monitoring on RPC errors
                }
            }
            
            sleep(Duration::from_millis(100)).await;
        }
        
        Ok(TransactionStatus::Unknown)
    }

    pub fn get_current_metrics(&self) -> SystemMetrics {
        let slot_info = self.slot_tracker.read().unwrap().clone();
        let priority_history = self.priority_history.read().unwrap();
        let pending_count = self.pending_txs.try_lock()
            .map(|txs| txs.len())
            .unwrap_or(0);
        
        let avg_priority_fee = if !priority_history.is_empty() {
            priority_history.iter()
                .map(|m| m.avg_priority_fee)
                .sum::<u64>() / priority_history.len() as u64
        } else {
            BASE_PRIORITY_FEE
        };
        
        SystemMetrics {
            current_slot: slot_info.slot,
            pending_transactions: pending_count,
            average_priority_fee: avg_priority_fee,
            slot_latency_ms: Instant::now().duration_since(slot_info.timestamp).as_millis() as u64,
        }
    }
}

#[derive(Debug, Clone)]
pub struct SlotTimingAnalysis {
    pub current_slot: u64,
    pub target_slot: u64,
    pub time_until_slot_ms: u64,
    pub optimal_submission_time_ms: u64,
    pub slot_progress_pct: f64,
}

#[derive(Debug, Clone)]
pub struct CompetitionAnalysis {
    pub current_score: f64,
    pub average_score: f64,
    pub trend: CompetitionTrend,
    pub recommended_priority_fee: u64,
    pub high_competition_slots: Vec<u64>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum CompetitionTrend {
    Increasing,
    Stable,
    Decreasing,
}

#[derive(Debug, Clone, PartialEq)]
pub enum TransactionStatus {
    Confirmed,
    Failed,
    Expired,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct SystemMetrics {
    pub current_slot: u64,
    pub pending_transactions: usize,
    pub average_priority_fee: u64,
    pub slot_latency_ms: u64,
}

impl Default for CompetitionAnalysis {
    fn default() -> Self {
        Self {
            current_score: 0.5,
            average_score: 0.5,
            trend: CompetitionTrend::Stable,
            recommended_priority_fee: BASE_PRIORITY_FEE,
            high_competition_slots: Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_priority_fee_calculation() {
        let keypair = Keypair::new();
        let config = TimePriorityConfig {
            rpc_url: "https://api.mainnet-beta.solana.com".to_string(),
            ws_url: "wss://api.mainnet-beta.solana.com".to_string(),
            payer_keypair: Arc::new(keypair),
            max_priority_fee: MAX_PRIORITY_FEE,
            slot_timing_offset: 0,
            competition_threshold: 0.7,
            adaptive_fee_enabled: true,
        };
        
        let exploiter = TimePriorityExploiter::new(config);
        let opportunity = exploiter.create_opportunity(
            "test".to_string(),
            vec![],
            1_000_000,
        ).unwrap();
        
        assert!(opportunity.priority_fee >= BASE_PRIORITY_FEE);
        assert!(opportunity.expected_profit == 1_000_000);
    }
}

